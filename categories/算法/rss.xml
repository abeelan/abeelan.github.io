<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on ABEE</title><link>https://abeelan.github.io/categories/%E7%AE%97%E6%B3%95/</link><description>Recent content in 算法 on ABEE</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 14 Aug 2023 18:53:51 +0000</lastBuildDate><atom:link href="https://abeelan.github.io/categories/%E7%AE%97%E6%B3%95/rss.xml" rel="self" type="application/rss+xml"/><item><title>算法 - 代理模式</title><link>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 14 Aug 2023 18:53:51 +0000</pubDate><guid>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起</description></item><item><title>算法 - 工厂设计模式</title><link>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 14 Aug 2023 18:53:37 +0000</pubDate><guid>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>当创建对象的代码多而杂时，可以用工厂模式将对象的创建和使用分离，让代码更清晰。 简单工厂 把创建大量实例的代码放到工厂类中。 # 普通实现 # 这种情况</description></item><item><title>算法 - 单例模式</title><link>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 14 Aug 2023 18:53:19 +0000</pubDate><guid>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>只允许类进行一次实例化。 饿汉式单例 类加载时就创建好实例。 class IdMaker: # 类变量 多个实例共享 __instance = None __id = 0 def __new__(cls): # python 在类加载阶段，通过父类的 __new__ 创建实例 # 重写</description></item><item><title>算法 - 递归算法</title><link>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 14 Aug 2023 18:53:03 +0000</pubDate><guid>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</guid><description>假设在排队，你不知道自己是第多少位。当你问前面一个人的时候，他也不知道自己是多少位，就会一直向前面问下去，因为是从自己这里开始问的，所以函数</description></item><item><title>算法 - 算法性能评估</title><link>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/</link><pubDate>Mon, 14 Aug 2023 18:51:39 +0000</pubDate><guid>https://abeelan.github.io/tech/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/</guid><description>评估算法好坏的两个指标： 时间复杂度 空间复杂度 影响时间复杂度的因素： 规模：测试数据的规模大小 环境：运行环境速度的快慢 大O 表示法 def tmp(n): add = 0 # 1 for</description></item></channel></rss>