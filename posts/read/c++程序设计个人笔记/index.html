<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《C++程序设计》个人笔记 | ABEE</title><meta name=keywords content="自考"><meta name=description content="一、C++ 简介 程序设计语言分为： 低级语言（机器语言、汇编语言） 中级语言 高级语言（C、C++等） C++ 语言的主要特点： 兼容 C 语言 面向对象（继承和多态） 引进了类和对象的概念 C++ 的基本数据类型 bool：布尔值 char：字符型 int：整型 float：浮点型 double：双精度浮点型 注释的两种方"><meta name=author content="ABEE"><link rel=canonical href=https://abeelan.github.io/posts/read/c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.fbe782675a7c7c9c739a48204d6d2a4da78a00e11ba93326b39891e3501b1740.css integrity="sha256-++eCZ1p8fJxzmkggTW0qTaeKAOEbqTMms5iR41AbF0A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://abeelan.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://abeelan.github.io/img/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://abeelan.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://abeelan.github.io/img/favicon.ico><link rel=mask-icon href=https://abeelan.github.io/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script><meta property="og:title" content="《C++程序设计》个人笔记"><meta property="og:description" content="一、C++ 简介 程序设计语言分为： 低级语言（机器语言、汇编语言） 中级语言 高级语言（C、C++等） C++ 语言的主要特点： 兼容 C 语言 面向对象（继承和多态） 引进了类和对象的概念 C++ 的基本数据类型 bool：布尔值 char：字符型 int：整型 float：浮点型 double：双精度浮点型 注释的两种方"><meta property="og:type" content="article"><meta property="og:url" content="https://abeelan.github.io/posts/read/c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-08T16:17:45+08:00"><meta property="article:modified_time" content="2023-04-08T16:17:45+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《C++程序设计》个人笔记"><meta name=twitter:description content="一、C++ 简介 程序设计语言分为： 低级语言（机器语言、汇编语言） 中级语言 高级语言（C、C++等） C++ 语言的主要特点： 兼容 C 语言 面向对象（继承和多态） 引进了类和对象的概念 C++ 的基本数据类型 bool：布尔值 char：字符型 int：整型 float：浮点型 double：双精度浮点型 注释的两种方"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚 分类","item":"https://abeelan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"📕 阅读","item":"https://abeelan.github.io/posts/read/"},{"@type":"ListItem","position":3,"name":"《C++程序设计》个人笔记","item":"https://abeelan.github.io/posts/read/c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《C++程序设计》个人笔记","name":"《C\u002b\u002b程序设计》个人笔记","description":"一、C++ 简介 程序设计语言分为： 低级语言（机器语言、汇编语言） 中级语言 高级语言（C、C++等） C++ 语言的主要特点： 兼容 C 语言 面向对象（继承和多态） 引进了类和对象的概念 C++ 的基本数据类型 bool：布尔值 char：字符型 int：整型 float：浮点型 double：双精度浮点型 注释的两种方","keywords":["自考"],"articleBody":"一、C++ 简介 程序设计语言分为：\n 低级语言（机器语言、汇编语言） 中级语言 高级语言（C、C++等）  C++ 语言的主要特点：\n 兼容 C 语言 面向对象（继承和多态） 引进了类和对象的概念  C++ 的基本数据类型\n bool：布尔值 char：字符型 int：整型 float：浮点型 double：双精度浮点型  注释的两种方式：\n 单行注释（//） 多行注释（/*..*/）  编写 C++ 程序一般需要经过四个步骤，依次是：编辑、编译、连接、运行。\n1. 头文件和命名空间 包含头文件需要使用 # include 指令，一条指令仅可以包含一个头文件，多个头文件需要使用多条指令。\n通常使用尖括号  包含系统头文件，会首先在系统设定的目录中寻找要包含的头文件；\n使用双引号 \"\" 包含自定义的头文件，会在当前用户目录下或指令中指定的目录下寻找要包含的头文件。\n# include  # include \"myCustom.h\" 常用的头文件：\n 标准输入/输出流： 标准文件流： 标准字符串处理函数： 标准数学函数：  文件后缀 .cpp 是源程序文件，文件后缀 .h 是头文件。\n命名空间的作用是消除同名引起的歧义。\nusing namespace std; // 自定义命名空间 namespace work { // work 为命名空间名  // 各种声明  class Foo {...}; func() {...}; }; // 使用方式一 using work::func(); // 使用方式二 推荐 using namespace work; Foo f; // 文件头声明后后面可以直接使用 func(); 2. 基本的输入/输出 当程序需要进行输入/输出信息时，需要包含头文件 \n  cin：使用流提取运算符 » 从标准输入设备键盘取得数据；\n  cout：使用流插入运算符 « 向标准输入设备屏幕输出信息。\n  # include  using namespace std; int main() { int a, b; cinab; cout\"a=\"a\"\\tb=\"bendl; return 0; } 3. 强制类型转换运算符 static_cast 把表达式类型转换为类型名所指定的类型，static_cast 也可以省略。\ndouble num = 3.12; n1 = static_castint(num); // 强制类型转换 n2 = int(num); // 强制类型转换运算符的新形式 n3 = (int) num; // 强制类型转换运算符的旧形式 n4 = num; // 自动类型转换 4. 函数参数的默认值 C++ 语言规定，提供默认值必须按从右至左的顺序提供，有默认值的形参必须在最后。\nvoid func(int a, int b=2, int c=3); // 正确 void func(int a=1, int b); // 错误，a 有默认值形参应该放在最后 void func(int a, int b=2, int c); // 错误，b 有默认形参应该放在最后 调用函数时，主调函数的实参与被调函数的形参按从左至右的顺序进行匹配对应。\nint func(float x, char y='$', int a=9, char b='@'); // 函数调用判断 func(3.14); // 正确，仅匹配 x，其他都有默认值 func(3.14, '#'); // 正确，匹配 x、y func(3.14, '%', '@'); // 错误，第三个参数类型不对应，预期 int，实际是 char func(3.14, '\u0026', 5, '*'); // 正确 func(3.14, , 5, '*'); // 错误，调用时的实参应该是连续排列的 5. 引用 引用相当于给变量起了个别名，对应于某个内存地址。如果给某个变量起了别名（不需要给它另开辟内存单元），相当于变量和这个引用都对应到同一地址。\n// 在程序中定义变量的引用 // 类型名 \u0026引用名 = 同类型的某变量名; # include  using namespace std; int main() { int foo = 1; int \u0026ref = foo; // ref 是 foo 的引用，等价于 foo \tconst int \u0026ref2 = foo; // 定义常引用  ref = 2; // foo=2; ref=2; ref2=2;  foo = 3; // foo=3; ref=3; ref2=3;  // ref2 = 4; 错误，不能使用常引用对所引用的变量进行修改  return 0; } 引用还可以用在函数中，既可以作为函数的参数使用，也可以作为函数的返回值使用。函数调用时参数的传递方式有两种：传值和传引用。\n传值，传递对象的值。将实参的值拷贝给形参，函数执行过程中，都是对这个拷贝进行操作的，执行完毕后，形参的值并不拷贝回实参。也就是函数内部对形参的改变不会影响到函数外实参的值。\n传引用，传递对象的首地址值。函数调用时，实参对象名传递给形参对象名，形参就成为实参的引用，他们是等价的，代表同一个对象。也可以看作是将实参的地址传递给了形参，函数内部对形参进行的改变，会影响到函数外实参的值。引用调用形参必须是引用。\n// 函数中使用引用  /* 例 1：引用作为参数传递 */ # include  using namespace std; void func(int x, int y) { // 传值  int tmp; tmp = x; x = y; y = tmp; cout\"func(): \"\"a=\"x\" b=\"yendl; } void func_ref(int \u0026x, int \u0026y) { // 传引用  int tmp; tmp = x; x = y; y = tmp; cout\"func_ref(): \"\"a=\"x\" b=\"yendl; } int main() { int a = 10, b = 20; func(a, b); cout\"调用 func() 后: a=\"a\" b=\"bendl; // func(): a=20 b=10  // 调用 func() 后: a=10 b=20  // 形参的改变没有影响函数外实参的值  func_ref(a, b); cout\"调用 func_ref() 后: a=\"a\" b=\"bendl; // func_ref(): a=20 b=10  // 调用 func_ref() 后: a=20 b=10  // 形参的改变影响了函数外实参的值  return 0; } /* 例 2：引用作为返回值 */ # include  using namespace std; int a = 10, b = 20; int \u0026ref(int \u0026x) { // 返回值是引用  return x; } int main() { ref(a) = 30; cout\"a=\"a\" b=\"bendl; // a=30 b=20  ref(b) = 40; cout\"a=\"a\" b=\"bendl; // a=30 b=40  return 0; } 6. const 与指针共同使用  const 用于约束某值不变，在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。\n // const 修饰普通变量 const int a = 10; int b = a; // 正确 a = 8; // 错误 不能改变 // a 被定义为一个常量 // 可以将 a 赋值给 b，但是不能对 a 再次赋值，不允许对常量重新赋值 const 修饰指针变量\n 情况一：左定值，const 修饰指针指向的内容，则内容为不可变量。\n const int *p = 8;\n如果唯一的 const 位于符号 * 的左侧，表示指针所指数据是常量，数据不能通过本指针改变，但可以通过其他方式修改。指针本身是变量，可以指向其他的内存单元。\n 情况二：右定向，const 指针指向的内存地址不能被改变，但其内容可以改变。\n int a = 8; int *const p = \u0026a; *p = 9; // 正确，内容可改变 int b = 7; p = \u0026b; // 错误，指针地址不能被改变 如果唯一的 const 位于符号 * 的右侧，表示指针本身是常量，不能让该指针指向其他内存地址。指针所指的数据可以通过本指针进行修改。\n 情况三：内容和指针内存地址都固定，不可改变。\n int a = 8; const int *const p = \u0026a; int const *const p = \u0026a; 如果在 * 的左右各有一个 const 时，表示指针和指针所指的数据都是常量，既不能让指针指向其他地址，也不能通过指针修改所指向的内容。\n7. 内联函数 为避免频繁的函数调用，使用内联函数，在编译时不生成函数调用，而是将程序中出现的每一个内联函数表达式替换为该内联函数的函数体。使用内联函数会使最终可执行程序的体积增大，以空间消耗节省时间开销。\n定义内联函数需要在函数头加上关键字 inline，定义在前，调用在后。内联函数主要应用于代码量少且频繁调用的函数，通常不建议内联函数体中包含循环语句或 switch 语句。\n# include  using namespace std; inline int Max(int x, int y) { return x  y ? x : y; } int main() { coutMax(20, 10)endl; coutMax(100, 500)endl; } 如果函数成员定义在类体内，则默认是内联函数。也可以在类体内部声明函数，并加上 inline 关键字，然后在类体外给出定义，这样也是内联函数。\n# include  using namespace std; class A { public: inline void print1(); // 类体外定义需要加 inline 关键字  void print2() { // 默认内联函数  cout\"print inline 2\"endl; } }; void A::print1() { cout\"print inline 1\"endl; } int main() { A a; a.print1(); a.print2(); } 8. 函数重载 函数重载是指在程序的同一范围内声明几个功能类似的同名函数，提高代码可读性。必须要满足条件之一：\n 参数表中参数类型不同（顺序不同也可） 参数表中参数个数不同  # include  using namespace std; int max(int x, int y) { return x  y ? x : y; } int max(float x, float y) { return x  y ? x : y; } int main() { coutmax(5, 8)endl; coutmax(3.14, 5.67)endl; } 如果两个函数的名字和参数表都是一样的，仅仅是返回值类型不同，则不符合函数重载的条件，编译报错。\n// 错误的函数重载 float max(float x, float y); int max (float x, float y); 采用引用参数也不符合函数重载。\n// 错误的函数重载 void print(double); void print(\u0026double); 避免产生二义性。\n// 错误的函数重载 int sum(int a, int b, int c=0); int sum(int a, int b); sum(1, 2); // 编译错误，不知道调用哪个函数 9. 指针和动态内存分配 C++ 中使用 new 运算符实现动态内存分配。指针变量中保存的是一个地址，也称指针指向一个地址。\nint *p; p = new int; // 动态分配 4 字节的内存空间 *p = 5; 使用 new 运算符也可以动态分配一个任意大小的数组。数组的长度是声明数组时指定的，不允许定义元素个数不明确的数组。\nint pArr; int n; pArr = new int[n]; // 错误，元素个数不明确 pArr = new int[5]; // 分配了 5 个元素的整型数组 pArr[0] = 10; // 数组的第一个值 pArr[4] = 20; // 数组的最后一个值 使用 pArr[-1] 或者 pArr[5]时，下标会越界。不过在编译时，对于数组越界的错误不会提示，运行时报错。\n使用 new 运算符动态申请的内存空间，需要在使用完毕后释放。使用 delete 运算符，用来释放动态分配的内存空间。\n/* 释放指针变量动态内存 */ int foo = 6; int *p = \u0026foo; delete p; // 错误，delete 后面的指针必须是指向动态分配的内存空间（new）  int *q = new int; *q = 8; delete q; // 正确，q 指向动态分配的空间  /* 释放数组动态内存 */ int *p = new int[100]; delete []p; 10. string 对象 C++ 标准模板库中提供了 string 数据类型，专门处理字符串。string 是一个类，这个类型的变量称为 string 对象。\n# include  // 需包含头文件  // 使用 string 类型初始化变量 string str = \"hello\"; string str2 = \"world\"; // 使用字符数组对 string 变量初始化 char name[] = \"hello, world.\"; string str = name; // 声明 string 对象数组 string citys[] = {\"beijing\", \"shenzhen\", \"shanghai\"}; str.empty() // 判断字符串是否为空 true false str.length() // 返回字符串长度 str.size() // 返回字符串占用空间字节数 str.append(\"haha\") // 向字符串后面追加内容 str.insert(4, \"123\") // 从字符串第四个位置插入内容 string 对象间可以相互赋值，不需要考虑空间是否足够的问题。\n11. C++ 语言的程序结构 C++程序以 .cpp 作为文件扩展名，文件中包含若干个类和若干个函数。程序中必须有且仅有一个主函数 main()，这是程序执行的总入口。程序从主函数的开始处执行，直到结束。主函数可以出现在任何地方。\n程序的结束通常是遇到了以下两种情况：\n 主函数中遇到了 return 语句 执行到了主函数最后的括号  主函数可以调用其他函数，但其他函数不能调用主函数。主函数仅是系统执行程序时调用的。\n二、面向对象的基本概念 结构化程序设计方法采用自顶向下、逐步求精及模块化思想，大问题化小问题。\n编写程序时使用 3 种基本控制结构：顺序、选择、循环，强调程序的易读性。\n面向对象程序设计方法就是使分析、设计和实现一个系统的方法 尽可能地接近 人们认识一个系统的方法。通常包括三方面：面向对象的分析、面向对象的设计、面向对象的程序设计。\n对象具有两个特性：\n 状态，指对象本身的信息（属性）； 行为，指对对象的操作。  通过对实物的抽象找出同一类对象的共同属性（静态特征）和行为（动态特征），从而得到类的概念。对象是类的一个具象，类是对象的一个抽象。C++ 中使用 对象名、属性、操作 三要素来描述对象。\n面向对象的程序设计有四个基本特点：\n  抽象：对象的属性和操作；\n  封装：通过自定义类来支持数据封装和信息隐藏；\n  继承：在已有类的基础上加上特殊的数据和函数构成新类，原来的类是基类（父类或超类），新类是派生类（子类）；\n  多态 ：不同种类的对象具有名称相同的行为，但具体的实现方式却不同。通过函数重载及运算符重载实现的多态。\n  1. 类的定义 类是具有唯一标识符的实体，类名不能重复。\n标识符命名规则：字母、数字、下划线 的组合，但不能以数字开头，大小写敏感，不能和系统中的关键字重名。类定义以 ; 结束，大括号中的部分称为类体。\n定义类时系统并不为类分配存储空间，类中声明的任何成员不能使用 auto、extern、register 关键字进行修饰。\n类中的成员按功能划分：\n 成员变量：对象的属性，个数不限，也称为数据成员。成员变量的声明方式与普通变量的声明方式相同； 成员函数：对象的操作，个数不限，声明方式与普通函数相同。  类中的成员按访问权限划分：\n 公有成员(public)：公有的，可以在程序任何地方访问； 私有成员(private) ：私有的，仅能在本类内访问；未定义则默认为私有； 保护成员(protected)：保护的，能在本类内及子类中被访问。  成员函数可以定义在类体内，也可以定义在类体外。可以定义不是任何类的成员的函数，称为全局函数。\n如果成员函数定义在类体外，则类体内必须要有函数原型声明，类体外定义函数必须使用类作用域运算符 ::。成员函数在内存中只有一份，可以作用于不同的对象，为类中各对象共享。\n#include using namespace std; class A { int foo = 1; // 定义成员变量，默认为私有成员  public: // 共有成员  void print(); // 类体内声明成员函数  A a; // 错误，不能定义本类的成员变量 }; // 注意类定义最后要加引号  void A::print() {}; // 类体外定义成员函数 2. 创建类对象的基本形式 class Test { public: Test(); Test(int x); }; /* 方法一 */ Test t1; // 类名 对象名; Test t2(5); // 类名 对象名(参数); Test t3 = Test(6); // 类名 对象名 = 类名(参数); Test t4, t5, t6(7), t7(10); // 扩展多个对象  /* 方法二 */ Test *p1 = new Test; // 类名 *对象指针名 = new 类名; Test *p2 = new Test(); // 类名 *对象指针名 = new 类名(); Test *p3 = new Test(5); // 类名 *对象指针名 = new 类名(参数); 用 new 创建对象时返回的是一个对象指针，指向创建的对象。创建的对象必须用 delete 来撤销。\n// 声明对象的引用 Test t1, t2; // 定义对象 Test \u0026t = t1; // 声明对象的引用 == 类名 \u0026对象引用名 = 对象; Test *p = \u0026t2; // 声明对象指针 == 类名 *对象指针名 = 对象的地址; Test ts[3]; // 声明对象数组 == 类名 对象数组名[数组大小]; 3. 访问对象的成员 定义了类对象后，就可以访问对象的成员。\n#include using namespace std; class Student { int age; public: char msg[40] = \"该学生年龄为：\"; int getAge(); void setAge(int); }; int Student::getAge() { return age; } void Student::setAge(int x) { age = x; } 3.1 通过对象访问  对象名.成员变量名 对象名.成员函数名(参数表)  int main() { Student s; s.setAge(18); // 成员函数  couts.msg; // 成员变量  couts.getAge()endl; return 0; } 3.2 通过指针访问 还可以使用指针或引用的方式来访问类成员，运算符 . 需要更换为 -。\nint main() { Student s; Student *p = \u0026s; p - setAge(19); coutp-msg; coutp-getAge()endl; return 0; } 3.3 通过引用访问 // 与通过对象访问方式一样 int main() { Student s; Student \u0026sr = s; sr.setAge(20); coutsr.msg; coutsr.getAge()endl; return 0; } 4. 标识符的作用域与可见性 标识符是组成程序的最小成分之一。类名、函数名、变量名、常量名和枚举类型的取值等都是标识符。\n标识符的作用域有：\n 函数原型作用域：函数声明时的形参，这是最小的作用域； 局部作用域(块作用域)：代码块内，比如循环语句内变量； 类作用域 命名空间作用域  类作用域有三种访问方式：\n 该类内的成员函数可以直接访问 在类外，通过类.成员或类::成员访问 在类外，通过类指针名-成员访问  具有命名空间作用域的变量称为全局变量。命名空间作用域有两种访问方式：\n 命名空间名::成员; using 命名空间名::成员; using namespace 命名空间名;  作用域的隐藏规则如下：\n  标识符声明在前，引用在后；\n  同一作用域中，不能声明同名标识符；\n  不同作用域中，可以声明同名标识符；\n  在具有包含关系的两个作用域中，外层声明的标识符：\n 如果没有在内层重新声明，外层标识符依然在内层可见； 如果在内层重新声明，则内层标识符隐藏外层同名标识符，这种机制称为隐藏规则。    类和对象进阶 1. 构造函数 基本数据类型的变量初始化：\n 全局变量：声明时没有初始化，则系统自动为其初始化为 0； 局部变量：声明时没有初始化，则是一个随机值。  构造函数的作用 对象的初始化，需要通过构造函数机制，来为对象成员变量赋初值。构造函数是类中的特殊成员函数，给出类定义时，需要编写构造函数，如果没有，则默认由系统添加一个不带参数的构造函数。\n声明对象后，使用 new 运算符为对象进行初始化，此时系统自动调用构造函数，完成对象的初始化工作，保证对象的初始状态是确定的。\n构造函数的定义 定义一个类时，需要为类定义相应的构造函数。构造函数的函数名与类名相同，没有返回值。\n一个类的构造函数可以有多个，允许重载，参数表一定不能完全相同。\n当类中没有定义任何构造函数时，系统会自动添加一个参数表和函数体都为空的默认构造函数。因此，任何类都保证至少有一个构造函数。\nclass myDate {}; // 定义构造函数 方式一 无参数 myDate::myDate() { year = 1970; month = 1; day = 1; } // 方式二 有参数 函数体内赋值 myDate::myDate(int y, int m, int d) { year = y; month = m; day = d; } // 方式三 另一种写法 myDate::myDate(): year(1970), month(1), day(1) {} // 赋初始值 myDate::myDate(int y, int m, int d): year(y), month(m), day(d) {} // 从参数列表取值 构造函数的使用 创建类的任何对象时都一定会调用构造函数进行初始化。如果程序中声明了对象数组，那么数组的每个元素都是一个对象，每个元素都要调用构造函数进行初始化。如果通过类仅声明了指针，并未与对象相关，则不会调用构造函数。\n// Test 是类 // 调用 4 次构造函数，声明指针不会调用 Test a(4), b[3], *p; 复制构造函数 复制构造函数是构造函数的一种，也称为拷贝构造函数。作用是使用一个已存在的对象去初始化另一个正在创建的对象。\n例如：类对象间的赋值是由复制构造函数实现的。\n复制构造函数只有一个参数，参数类型是本类的引用。一个类中可以写两个复制构造函数，函数的参数分别为 const 引用和非 const 引用。\n以下三种情况会自动调用复制构造函数：\n 用一个对象去初始化另一个对象 作为函数形参的对象 作为函数返回值的对象  class A{ public: int x; A(int t) {x = t;} // 有参构造函数  A(A \u0026t) {x = t.x;} // 复制构造函数一  A(const A \u0026t) {x = t.x;}; // 复制构造函数二 }; int main() { A a(10); couta.xendl; // 10  A b(a); coutb.xendl; // 10  return 0; } 2. 析构函数 析构函数也是成员函数的一种，名字与类名相同，但要在类名前加一个 ~ 符号，以区别构造函数。\n析构函数没有参数，也没有返回值。一个类中有且仅有一个析构函数。如果未定义，则系统自动生成函数体为空的默认析构函数。\n析构函数的作用是做一些善后处理的工作，当对象消亡时自动调用析构函数。比如通过 new 创建的对象，使用 delete 释放空间时，首先调用对象的析构函数，然后再释放对象占用的空间。\n对于对象数组，要为它的每个元素调用一个构造函数和析构函数。析构函数的调用执行顺序与构造函数正好相反。\n#include using namespace std; class Test { public: Test(); ~Test(); private: int *p; }; Test::Test() { cout\"Test 构造函数\"endl; p = new int[10]; // 指针指向堆空间 } Test::~Test() { cout\"Test 析构函数\"endl; delete p; // 必须显式的声明析构函数，释放空间，避免内存泄漏 } int main() { Test t; return 0; } 3. 变量及对象的生存期和作用域 全局变量\n 未赋初值默认为 0，字符型变量为空字符 作用域：定义在函数外，可被所有文件的函数使用，其他文件使用需 extern 声明（外部链接） 生存期：整个程序执行期 不同文件的全局变量不可以重名  局部变量\n 未赋初值，内容为随机 作用域：程序块内 生存期：程序块执行期 同一文件中全局变量和局部变量可以重名，在局部变量作用域内，全局变量不起作用  静态全局变量\n 值只初始化一次，未赋初值默认为 0，字符型变量为空字符 作用域：本文件内，存储在全局数据区 生存期：整个程序执行期 不同文件的静态全局变量可以重名  静态局部变量\n 值只初始化一次，未赋初值默认为 0，字符型变量为空字符 作用域：程序块内，存储在全局数据区 生存期：整个程序执行期  使用 new 创建的变量具有动态生存期，从声明处开始，直到用 delete 释放存储空间或程序结束。\n类对象的生存期为调用构造函数开始到消亡时调用析构函数。\n4. 类的静态成员 类的静态成员分为：\n 静态成员变量 静态成员函数  类的静态成员只有一份保存在公用内存中，被类的所有对象共享。静态成员定义时，需要在前面添加 static 关键字。必须在类体外赋静态成员变量的初值。\n#include using namespace std; class Book { public: static int page_num; // 静态数据成员  static void print() { // 静态函数才能调用静态变量  cout\"已阅读到的页码为：\"page_numendl; } }; int Book::page_num = 100; // 静态数据成员的初值只能在类体外定义，不需要加 static 关键字  int main() { Book b1, b2, *b3; b1.print(); // 100  b2.print(); // 100 该类的所有对象公用一个静态数据成员  // 静态成员访问的三种方法  coutBook::page_numendl; // 类名.静态成员名  coutb1.page_numendl; // 对象.静态成员名  coutb3-page_numendl; // 对象指针-静态成员名  return 0; } 类的静态函数只能处理类的静态成员变量。静态函数与静态函数之间、非静态函数与非静态函数之间是可以相互调用的，非静态成员函数内可以调用静态成员函数，但静态成员函数内不能调用非静态成员函数。\n5. 常量成员和常引用成员 在类中，可以使用关键字 const 定义成员变量、成员函数、类的对象。\n类的常量成员变量必须进行初始化，且只能通过构造函数的成员初始化列表的方式进行。\n定义常量成员变量或常量对象：const 数据类型 常量名 = 表达式;\n定义常量函数：类型说明符 函数名(参数表) const;\n对象被创建以后，常量成员变量的值不允许被修改，只可以读其值。对于常量对象，只能调用常量函数。\nclass A { public: void test() {} // 非常量成员函数  void demo() const {} // 常量成员函数 }; int main() { const A a; a.test(); // 错误 常量对象不能调用非常量成员函数  a.demo(); // 正确 } 6. 成员对象和封闭类 一个类的成员变量如果是另一个类的对象，则该成员变量称为成员对象。这两个类为包含关系，包含成员对象的类叫做封闭类。\n#include using namespace std; class Tyres { private: int radius, width; public: Tyres(int r, int w): radius(r), width(w) { cout\"Tyres(radius=\"radius\", width=\"width\")\"endl; }; }; class Car { private: int prices; Tyres tyres; public: Car(int p, int tr, int td); }; // 定义封闭类构造函数中，需要指明调用成员对象的哪个构造函数 如：Tyres(int, int) Car::Car(int p, int tr, int td): prices(p), tyres(tr, td) { cout\"Gogogo!\"endl; // 先调用成员对象的构造函数，在调用封闭类对象的构造函数 } int main() { Car car(100, 3, 6); return 0; } // Tyres(radius=3, width=6) // Gogogo! 7. 友元函数 设置私有成员的机制叫做隐藏。修改私有属性需要通过公有函数，函数内可以避免对对象的不正确操作或做一些其他修改。私有类型的成员在类外不能访问，通过类内公有函数可以访问但是比直接访问的效率低，所以提供了友元访问方式。\n友元函数内部可以直接访问本类对象的私有成员，友元函数不是类的成员函数，但允许访问类中的所有成员。不受类中的访问权限关键字限制，可以把它放在类的公有、私有、保护部分，结果是一样的。友元的概念破坏了类的封装性和信息隐藏，但有助于数据共享，能够提高程序执行的效率。\n友元函数使用关键字 friend 标识，定义方式 ：\n  friend 返回值类型 函数名(参数表);\n  friend 返回值类型 类名::函数名(参数表);\n  一个函数可以声明为多个类的友元函数，一个类中也可以有多个友元函数。\n友元类 如果将一个类 B 说明为类 A 的友元类，则类 B 中的所有函数都是类 A 的友元函数，在类 B 的所有成员函数中都可以访问类 A 中的所有成员。\n声明格式为：friend class 类名;\n友元类的关系是单向的，友元类的关系不能传递。一般不把整个类说明为友元类。\n8. this 指针 当调用一个成员函数时，系统自动向它传递一个隐含的参数，该参数是一个指向调用该函数的对象的指针，称为 this 指针，从而使成员函数知道对哪个对象进行操作。\n  非静态成员函数内部可以直接使用 this 关键字，代表指向该函数所作用的对象的指针\n  静态成员函数没有 this 指针\n  一般情况下，可以省略 this-，系统采用默认设置\n  运算符重载 运算符重载的概念 算术运算符包括：+ - * / %，通常只能用于对基本数据类型的常量或变量进行运算，而不能用于对象之间的运算。运算符重载可以使运算符也能用来操作对象。\n重载运算符有一个返回类型和一个参数列表，这样的函数称为运算符函数。运算符可以被重载为全局函数，也可以被重载为类的成员函数。声明为全局函数时，通常应是类的友元。运算符函数是一种特殊的友元函数或成员函数。\n重载运算符的规则  符合原有的用法习惯 不能改变运算符原有的语义 不能改变运算符操作数的个数及语法结构 不能创建新的运算符 重载运算符() [] - = 时，只能重载为成员函数，不能为全局函数 不能改变运算符用于基本数据类型对象的含义  myComplex operator+(const myComplex \u0026 c1, const myComplex \u0026 c2) { return myComplex(c1.real + c2.real, c1.imag + c2.imag); } myComplex operator+(const myComplex\u0026 c1, double r) { return myComplex(c1.real + r, c1.imag); } myComplex operator+(double r, const myComplex\u0026 c1) { return myComplex(r + c1.real, c1.imag); } myComplex operator-(const myComplex\u0026 c1, const myComplex\u0026 c2) { return myComplex(c1.real - c2.real, c1.imag - c2.imag); } myComplex operator-(const myComplex\u0026 c1, double r) { return myComplex(c1.real - r, c1.imag); } myComplex operator-(double r, const myComplex\u0026 c1) { return myComplex(r - c1.real, -c1.imag); } 重载赋值运算符 赋值运算符 = 只能重载为成员函数。\nmyComplex\u0026 myComplex::operator=(const myComplex\u0026 c1) { this-real = c1.real; this-imag = c1.imag; return *this; } myComplex\u0026 myComplex::operator=(double r) { this-real = r; this-imag = 0; return *this; } 同类对象之间可以通过赋值运算符进行赋值。如果没有经过重载，= 的作用就是将赋值号右侧对象的值一一赋值给左侧的对象。这相当于值的拷贝，称为浅拷贝。重载赋值运算符后，赋值语句的功能是将一个对象中指针成员变量指向的内容复制到另一个对象指针成员变量指向的地方，这样的拷贝叫深拷贝。\n重载流插入运算符和流提取运算符  流插入运算符(cout)  流提取运算符(cin)   只能采用友元函数重载的方式。\n#include   class Test { private: int i; float f; char ch; public: test(int a=0, float b=0, char c='\\0') {i=a; f=b; ch=c;} friend ostream \u0026operator(ostream \u0026, test); // 必须重载为类的友元  friend istream \u0026operator(istream \u0026, test \u0026); // 必须重载为类的友元 }; ostream \u0026operator(ostream \u0026stream, test obj) { streamobj.i\",\"; // stream 是 cout 的别名  streamobj.f\",\"; streamobj.chendl; return stream; } istream \u0026operator(istream \u0026t_stream, test \u0026obj) { t_streamobj.i; // t_stream 是 cin 的别名  t_streamobj.f; t_streamobj.ch; return t_stream; } void main() { test A; operator(cout, \"Input as i f ch:\"); operator(cin, A); // 45,8.5,'W’  operator(cout,A); // 45,8.5,'W’  return 0; } 重载自增、自减运算符   自增运算符：++k k++\n  自减运算符：--k k--\n  按照定义，++k 返回被修改后的值，k++ 返回被修改前的值。\n# include  using namespace std; class Demo { private: int n; public: Demo(int i=0): n(i) {} operator int() {return n;} Demo \u0026 operator++(); // 用于前置形式  Demo operator++(int); // 用于后置形式 }; Demo \u0026Demo::operator++() { n++; return *this; } Demo Demo::operator++(int k) { Demo tmp(*this); // 记录修改前的对象  n++; return tmp; // 返回修改前的对象 } int main() { Demo d(10); // 后置形式两种写法  cout(d++)endl; // 10  coutdendl; // 11  d.operator++(0); // 11 不输出 有参代表后置形式  coutdendl; // 12  // 前置形式两种写法  cout(++d)endl; // 13  d.operator++(); // 14 不输出 无参代表前置形式  coutdendl; // 14  return 0; } 类的继承与派生 通过已有的类建立新类的过程，叫做类的派生。\n 原来的类称为基类、父类、一般类； 新类称为派生类、子类、特殊类。  派生类继承于基类，基类派生了派生类，派生类可以作为基类再次派生新的派生类，这种集合称作类继承层次结构。\n使用基类派生新类时，除构造函数和析构函数外，基类的所有成员自动成为派生类的成员，包括基类的成员变量和成员函数。派生类中需要定义自己的构造函数和析构函数，可以增加基类中没有的成员，还可以重新定义或修改基类中已有的成员，包括可以改变基类中成员的访问权限。\n// 基类与派生类的定义 class Base { int a, b; }; class Derived: public Base { int c; }; 派生类占用的存储空间大小，等于基类成员变量占用存储空间大小 加上 派生类对象自身成员变量占用的存储空间大小。对象占用的存储空间包含对象中各成员变量占用的存储空间。可以使用 sizeof() 计算对象占用的字节数。\n基类有友元，派生类不会继承友元类或友元函数。如果基类是某类的友元，那么这种友元关系是继承的。如果基类中的成员是静态的，在派生类中静态属性随静态成员被继承。如果基类的静态成员是公有的或者保护的，则他们被其派生类继承为派生类的静态成员。\nC++ 允许从多个类派生一个类，即一个派生类可以同时有多个基类。这称为多重继承。相应地，从一个基类派生一个派生类的情况，称为单继承或单重继承。\n#include using namespace std; class C1 {}; class C2 {}; class C3: public C1, public C2 { cout\"多重继承\"endl; };  如果派生类中新增了同名成员，则派生类成员将隐藏所有基类的同名成员，使用派生类对象名.成员名 或 派生类对象指针-成员名 的方式可以唯一标识和访问派生类的新增成员。这种情况下，不会产生二义性。 如果派生类中没有新增同名成员，使用上面的方式访问成员时，系统无法判断到底调用哪个基类的成员，产生二义性，为避免这种情况，必须通过 基类名和作用域分辨符 来标识成员。当访问派生类对象中某个变量时，添加 基类:: 作为前缀，指明访问从哪个基类集成来的成员。  访问控制  public：共有继承 private：私有继承 protected：保护继承  类的共有继承\n   各成员 派生类中 基类与派生类外     基类的公有成员 直接访问 直接访问   基类的保护成员 直接访问 调用公有函数访问   基类的私有成员 调用公有函数访问 调用公有函数访问   从基类继承的公有成员 直接访问 直接访问   从基类继承的保护成员 直接访问 调用公有函数访问   从基类继承的私有成员 调用公有函数访问 调用公有函数访问   派生类中定义的公有成员 直接访问 直接访问   派生类中定义的保护成员 直接访问 调用公有函数访问   派生类中定义的私有成员 直接访问 调用公有函数访问    类的私有继承\n    第一级派生类中 第二级派生类中 基类与派生类外     基类的共有成员 直接访问 不可访问 不可访问   基类的保护成员 直接访问 不可访问 不可访问   基类的私有成员 通过公有函数访问 不可访问 不可访问    类型兼容规则 在公有派生的情况下，有以下三条兼容规则：\n 派生类的对象可以赋值给基类对象； 派生类的对象可以用来初始化基类引用； 派生类对象的地址可以赋值给基类指针，即派生类的指针可以赋值给基类的指针。  派生类的构造函数与析构函数 在执行一个派生类构造函数之前，总是先执行基类的构造函数。派生类对象消亡是时，先执行派生类的析构函数，在执行基类的析构函数。\n#include  using namespace std; //基类 class BaseClass { protected: int v1,v2; public: BaseClass(); BaseClass(int,int); ~BaseClass(); }; BaseClass::BaseClass() { cout\"BaseClass 无参构造函数\"endl; } BaseClass::BaseClass(int m, int n) { v1=m; v2=n; cout\"BaseClass 无参构造函数\"endl; } BaseClass::~BaseClass() { cout\"BaseClass 析构函数\"endl; } // 派生类 class DerivedClass:public BaseClass { private: int v3; public: DerivedClass(); DerivedClass(int); DerivedClass(int,int,int); ~DerivedClass(); }; DerivedClass::DerivedClass() { cout\"DerivedClass 无参构造函数\"endl; } DerivedClass::DerivedClass(int k):v3(k) { cout\"DerivedClass 带1个参数构造函数\"endl; } DerivedClass::DerivedClass(int m, int n, int k):BaseClass(m, n), v3(k) { cout\"DerivedClass 带3个参数构造函数\"endl; } DerivedClass::~DerivedClass() { cout\"DerivedClass 析构函数\"endl; } int main() { cout\"无参对象的创建\"endl; BaseClass b; DerivedClass d; return 0; } /* 输出内容： 无参对象的创建 BaseClass 无参构造函数 BaseClass 无参构造函数 DerivedClass 无参构造函数 DerivedClass 析构函数 BaseClass 析构函数 BaseClass 析构函数 */ 派生类构造函数执行顺序一般次序如下：\n 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右） 对派生类新增的成员变量初始化，调用顺序按照它们在类中声明的顺序 执行派生类的构造函数体重的内容  在派生类构造函数执行之前，要先执行两个基类的构造函数，执行次序依据定义派生类时所列基类的次序而定。\n类之间的关系 使用已有类编写新的类有两种方式：\n 继承关系：也称为 is a 关系或 是 关系 组合关系：也称为 has a 关系或 有 关系，表现为封闭类  封闭类：如果一个类的成员变量是另一个类的对象，则为封闭类。\n如果基类为封闭类，函数调用顺序如下：\n 构造函数：对象成员构造函数 - 基类构造函数 - 派生类构造函数 析构函数：派生类析构函数 - 基类析构函数 - 对象成员析构函数  互包含关系的类，两个类相互引用，这种情况称为循环依赖。\n多层次的派生  派生类沿着类的层次自动向上继承它所有的直接和间接基类的成员，类之间的继承关系具有传递性 派生类的成员包括派生类自己定义的成员、直接基类中定义的成员及所有间接基类中定义的全部成员 当生成派生类的对象时，会从最顶层的基类开始逐层往下执行所有基类的构造函数，最后执行派生类自身的构造函数；当派生类对象消亡时，会先执行自身的析构函数，然后自底向上依次执行各个基类的析构函数  一个类不能被多次说明为某个派生类的直接基类，可以不止一次地称为间接基类。\n基类与派生类指针的相互转换 在公有派生的情况下，因为派生类对象也是基类对象，所以派生类对象可以赋给基类对象。\n对于指针类型，可以使用基类指针指向派生类对象，也可以将派生类的指针直接赋值给基类指针。但即使基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类中没有而仅在派生类中定义的成员函数。\n多态与虚函数 多态的基本概念 多态 多态分为：\n 编译时多态：函数的重载（包括运算符重载）。编译时根据实参确定应该调用哪个函数，编译阶段的多态称为静态多态，一个对象调用同名函数； 运行时多态：和继承、虚函数等概念有关，主要指运行时多态，运行阶段的多态称为动态多态，不同对象调用同名函数。  在类直接满足 赋值兼容的前提下，实现动态绑定必须满足两个条件：\n 必须声明虚函数 通过基类类型的引用或指针调用虚函数  多态实现原理：多态的关键在于通过基类指针或引用调用一个虚函数时，编译阶段不能确定到底调用的是基类还是派生类的函数，运行时才能确定。\n派生类对象占用的存储空间大小，等于基类成员变量占用的存储空间大小加上派生类对象自身成员变量占用的存储孔家你大小。\n虚函数  在函数声明前加了 virtual 关键字的成员函数 只能在类定义中的成员函数声明处使用，类体外编写函数体时不加该关键字 不能声明为虚函数的有：全局函数（非成员函数）、静态成员函数、内联函数、构造函数和友元函数 不要在构造函数和析构函数中调用虚函数 最好将基类的析构函数声明为虚函数 包含虚函数的类称为 多态类 派生类重写基类的虚函数实现多态，要求函数名、参数列表和返回值类型要完全相同 基类中定义了虚函数，在派生类中该函数始终保持虚函数的特性  #include using namespace std; class Base1 { public: void show() { cout\"Base1::show()\"endl; } }; class Base2: public Base1 { public: void show() { cout\"Base2::show()\"endl; } }; class Derived: public Base2 { public: void show() { cout\"Derived::show()\"endl; } }; // 通过基类类型的指针或引用调用 void func(Base1 *p) { p - show(); } int main() { // b1 是基类，b2 继承自 b1，d 继承自 b2  // 通过子类对象赋值给基类时，调用同名方法都会变成基类的方法  // 没有实现多态  Base1 b1; Base2 b2; Derived d; func(\u0026b1); func(\u0026b2); func(\u0026d); return 0; } /* Base1::show() Base1::show() Base1::show() */ 通过虚函数实现多态\nclass Base1 { public: virtual void show() { cout\"Base1::show()\"endl; } }; /* 只需要修改基类的同名方法为虚函数，派生类中自然继承 再次执行，输出结果为：实现多态 Base1::show() Base2::show() Derived::show() */ 虚析构函数 如果一个基类指针指向的对象是用 new 运算符动态生成的派生类对象，那么释放该对象所占用的空间时，如果仅调用基类的析构函数，则只会完成该析构函数内的空间释放，不会涉及派生类析构函数内的空间释放，容易造成内存泄漏。\n使用虚析构函数的目的是为了在对象消亡时实现多态。\n声明虚析构函数格式：virtual ~类名();\n 虚析构函数没有返回值类型，没有参数 如果一个类的析构函数是虚函数，那么由它派生的所有子类的析构函数都是虚析构函数  #includeusing namespace std; class Base { public: Base() { cout\"Base::构造函数\"endl; } // 虚析构函数，子类自动也变为虚析构函数  virtual ~Base() { cout\"Base::析构函数\"endl; } }; class Derived: public Base { public: int w,h; //两个成员  Derived() { cout\"Derived::构造函数\"endl; w=4; h=7; } ~Derived() { cout\"Derived::析构函数\"endl; } }; int main() { Base *p = new Derived(); //使用基类指针指向new创建的派生类对象  delete p; return 0; } /* 输出： Base::构造函数 Derived::构造函数 Derived::析构函数 // 如果声明虚析构函数的话，就不会调用派生类的析构函数了 Base::析构函数 */ 纯虚函数 纯虚函数的作用相当于一个统一的接口形式，表明在基类的各派生类中应该有这样的一个操作，然后在各派生类中具体实现与本派生类相关的操作。\n纯虚函数是声明在基类中的虚函数，没有具体定义。\n声明格式：virtual 函数类型 函数名(参数表) = 0;\n抽象类 包含纯虚函数的类称为抽象类。因为抽象类中含有未完成的函数定义，所以不能实例化一个对象。\n抽象类的派生类中，如果没有给出全部纯虚函数的定义，则该派生类继续是抽象类。\n虽然不能创建抽象类对象，但是可以定义抽象类的指针和引用。\n// 假设 Foo 为抽象类 Foo *p; 虚基类 #include  using namespace std; class A { public: int a; void showa() { cout\"a=\"aendl; } }; class B: virtual public A { // 对类 A 进行了虚继承 public: int b; }; class C: virtual public A { //对类 A 进行了虚继承 public: int c; }; class D: public B, public C { // 派生类 D 的两个基类 B、C 具有共同的基类 A, // 采用了虚继承，从而使类 D 的对象中只包含着类 A 的 1 个实例 public: int d; }; int main() { D d; // 说明派生类D的对象  d.a = 11; // 若不是虚继承，此行会出错!因为\"D::showa\"具有二义性  d.b = 22; d.showa(); // 输出 11，若不是虚继承，D::showa 具有二义性  cout\"d.b=\"d.bendl; //输出Dobj.b=22 } 消除二义性。\n输入/输出流 流类简介 C++中凡是数据从一个地方传输到另一个地方的操作都是流的操作。\n 读操作：被称为(从流中)“提取” 写操作：被称为(向流中)“插入”  为了避免多重继承的二义性，从 ios 派生 istream 和 ostream 时，均使用了 virtual 关键字（虚继承）。\n istream：提供了流的大部分输入操作，对系统预定义的所有输入流重载提取运算符  ostream：对系统定义的所有输出流重载插入运算符   iostream 类库 常见的头文件：\n iostream：包含操作所有输入/输出流所需要的基本信息 iomanip：setw()、setprecision()、setfill()、setbase() 等 fstream：包含处理文件的有关信息，童工建立文件、读/写文件的各种操作接口  iostream 头文件 iostream 包含操作所有输入/输出流所需的基本信息，含有 4 个标准流对象：\n cout：标准输出流，与标准输出设备（显示器）相关联，可以被重定向为向文件里写入数据； cin：标准输入流，与标准输入设备（键盘）相关联，可以被重定向为从文件中读取数据； cerr：输出错误信息，与标准错误信息输出设备（显示器）相关联（非缓冲），不能被重定向； clog：输出错误信息，与标准错误信息输出设备（显示器）相关联（缓冲），不能被重定向。  // 将标准输出cout重定向到文件 #include using namespace std; int main() { int x,y; cinxy; freopen(\"test.txt\", \"w\", stdout); // 将标准输出重定向到文件test.txt  if(y==0) // 除数为0, 则输出错误信息 \tcerr\"error.\"endl; else coutx\"/\"y\"=\"x/yendl; return 0; } 函数 freopen() 的功能是将 stream 按 mode 指定的模式重定向到路径 path 指向的文件。\niomanip C++ 进行 I/O 格式控制的方式一般有使用流操纵符、设置标志字和调用成员函数。\n流操纵符 不带参数的流操纵符：\n endl（O）：换行符，输入一个换行符，清空流 ends（O）：输出字符串结束，清空流 flush（O）：清空流缓冲区 dec（I/O，默认）：十进制形式 hex（I/O）：十六进制形式 oct（I/O）：八进制形式 ws（O）：提取空白字符  包含格式化 I/O 的带参数流操纵符，可用于指定数据输入/输出的格式。例如：\n setw(int w)：指定输出宽度为 w 个字符，或输入字符串时读入 w 个字符，一次有效 setprecision()：设置有效数字位数，全部数字个数 setfill()：指定输出宽度，宽度不足时用空格填充 setbase()：输入表示数值进制的前缀 setiosflags()：设置标志字  进制标识：\n 十六进制常量——前缀0x，0~9、a~f 十进制常量——无前后缀，0~9 八进制常量——前缀0，0~7；080就是非法数 长整型常量——后缀L或l  标志字 #include #include using namespace std; int main() { double x=12.34; cout\"1)\"setiosflags(ios::scientific|ios::showpos)xendl; // ios::scientific 科学计数法 showpos 正数前加 “+” 号  // 输出：+1.234000e+001  cout\"2)\"setiosflags(ios::fixed)xendl; // fixed 定点形式表示浮点数  // +12.34  cout\"3)\"resetiosflags(ios::fixed)setiosflags(ios::scientific|ios::showpos)xendl; // +1.2340003+001  cout\"4)\"resetiosflags(ios::showpos)xendl; // 清除要输出正号的标志  // 1.234000e+001  return 0; } 调用 cout 的成员函数    成员函数 作用相同的流操纵符     precision(int np) setprecision(np)   width(int nw) setw(nw)   fill(char cFill) setfill(cFill)   setf(long iFlags) setiosflags(iFlags)   unsetf(long iFlags) resetiosflags(iFIags)    cout.put('d'); // coutcout.write(); // 向输出流汇总插入 数据块 调用 cin 的成员函数 // get() 函数 while((ch=cin.get()) != EOF) //当文件没有结束时继续进行循环 { cout.put(ch); } // getline() 函数，从输入流中读取一行字符 // 函数原型 istream \u0026 getline(char * buf, int bufSize); // 读取 size-1 个字符到缓冲区 或到 \\n 截止 istream \u0026 getline(char * buf, int bufSize, char delim); // 或到 delim 截止  // eof() 函数，用于判断输入流是否已经结束，返回 true 表示输入结束 // 测试是否到文件尾，到文件返回 1，否则返回 0 bool eof( ); // ignore() 函数，跳过输入流中的 n 个字符 或 delim 及其之前的所有字符 // cin.ignore() == cin.ignore(1, EOF) 默认值，即跳过一个字符 istream \u0026 ignore(int n=1, int delim=EOF); // peek() 函数，返回输入流中的当前字符，只看一眼 // 输入流已经结束的情况下，cin.peek() 返回 EOF int peek( ); 文件和操作 文件基本概念和文件流类 根据文件数据的编码方式不同分为：\n  文本文件\n  二进制文件\n  根据存取方式不同分为：\n 顺序存取文件：按照文件中数据存储次序进行顺序操作，访问第 i 个数据，首先得访问 i-1 随机存取文件：根据应用需要，通过命令移动位置指针直接定位到文件位置  对文件的基本操作分为：\n 读文件：将文件中的数据读入内存之中，也称为输入 写文件：将内存中的数据存入文件之中，也称为输出  C++ 标准类库中有 3 个流类可以用于文件操作，统称为文件流类，分别如下：\n ifstream：用于从文件中读取数据 ofstream：用于向文件中写入数据 fstream：即可用于读取数据，也可用于写入数据  使用这 3 个流类，需要包含 fstream 头文件。\n在程序中，要使用一个文件，必须包含3个基本步骤：\n 打开(open)文件 操作文件：对文件进行读/写 关闭(close)文件  C++ 文件流类有相应的成员函数来实现打开、读、写、关闭等文件操作。\n打开和关闭文件 打开文件的方式有以下两种:\n 先建立流对象，然后调用 open() 函数连接外部文件。格式如下: 流类名 对象名; 对象名.open(文件名, 模式); 调用流类带参数的构造函数，建立流对象同时连接外部文件，格式如下： 流类名 对象名(文件名，模式);  // 输入：方式一 ifstream inFile; //建立输入文件流对象 inFile.open(\"data.txt\", ios::in); //连接文件，指定打开模式，默认为 in // 输入：方式二 ifstream inFile(\"data.txt\", ios::in); // 输出：方式一 ofstream outFile; //建立输入文件流对象 outFile.open(\"c:\\\\c2019\\\\newfile\",ios::out | ios::binary); // 二进制文件 // 输出：方式二 ofstream outFile(\"c:\\\\c2019\\\\newfile\",ios::out | ios::binary); 使用 fstream 中的成员函数 close() 关闭文件。\ninFile.close(); outFile.close(); 文件读写操作 读写文本文件 /* 键盘输入学生的学号、姓名和成绩，存入 score.txt 中 每行保存一名学生的成绩信息，各项数据之间用空格分隔 */ #include #include using namespace std; int main() { char id[11], name[21]; int score; // 写文件  ofstream outFile; outFile.open(\"score.txt\", ios::out); // 写方式打开文件  if (!outFile) { cout\"创建文件失败！\"endl; return 0; } cout\"请输入：学号 姓名 成绩（以 Ctrl+Z 结束！）\"; while(cinidnamescore) outFileid\" \"name\" \"scoreendl; //向流中插入数据  outFile.close(); // 读文件  iftream inFile(\"score.txt\", ios:in); // 读方式打开文件  if (!inFile) { cout\"打开文件失败！\"endl; return 0; } cout\"学生学号 姓名\\t\\t\\t成绩\\n\"; while(inFileidnamescore) // 读入文件 \tcoutleftsetw(10)id\" \"; coutsetw(20)name\" \"; coutsetw(3)rightscoreendl; inFile.close( ); return 0; } 读写二进制文件 需要用 binary 方式打开二进制文件。\n// 用 ostream::write() 成员函数写文件 ostream \u0026 write(char * buffer, int nCount); // e.g. ofstream outFile(\"students.dat\",ios::out|ios::binary); outFile.write((char*)\u0026stu, sizeof(stu)); // 用 istream::read() 成员函数读文件 istream \u0026read(char * buffer, int nCount); // 用 ostream::gcount() 成员函数得到读取字节数 int gcount(); 用成员函数 put() 和 get() 读写文件 // 不带参数，提取一个字符并返回，当遇到文件结束符，返回 EOF int get(); // 从指定输入流中提取一个字符 istream\u0026 get(char \u0026rch); // 从流的当前字符开始，读取 nCount-1 个字符，到 delim 结束 istream\u0026 get(char *pch, int nCount, char delim=’\\n’); // put 向输出流中插入一个字节 ostream\u0026 put(char ch); 文本文件与二进制文件异同 在输入/输出过程中，系统要对内外存的数据格式进行相应转换。\n  文本文件：以文本形式存储数据\n 优点：具有较高的兼容性 缺点：1.存储一批纯数值信息时，要人为地添加分隔符；2.不便于对数据进行随机访问。    二进制文件：以二进制形式存储数据\n 优点：便于对数据实行随机访问 (相同数据类型的数据所占空间的大小均是相同的，不必在数据之间人为地添加分隔符)，在输入/输出过程中，系统不需要对数据进行任何转换。 缺点：数据兼容性差    通常纯文本信息(如字符串)以文本文件形式存储，而将数值信息以二进制文件形式存储。\n随机访问文件 顺序文件：如果一个文件只能进行顺序存取操作，则称为顺序文件。\n 典型的顺序文件 (设备)是键盘、显示器和保存在磁带上的文件 在访问文件的过程中，若严格按照数据保存的次序从头到尾访问文件，则称为顺序访问 只能进行顺序访问  随机文件：如果一个文件可以在文件的任意位置进行存取操作，则称为随机文件。\n  磁盘文件就是典型的随机文件\n  在访问文件的过程中，若不必按照数据的存储次序访问文件，而是要根据需要在文件的不同位置进行访问，则称为随机访问\n  既可以进行顺序访问，也可以进行随机访问\n  **类 istream **中与位置指针相关的函数如下:\n/* 1. 移动读指针函数 */ // 该函数的功能是将读指针设置为 pos，即将读指针移动到文件的 pos 字节处 istream \u0026 seekg(long pos); // 将读指针按照 seek_dir 的指示(方向)移动offset个字节 // 其中seek_dir 是在类ios中定义的一个枚举类型 enum seek_dir {beg=0, cur, end}; // ios::beg 流的开始位置。此时，offset 应为非负整数 // ios::cur 表示流的当前位置。offset 为正数则表示向后(文件尾)移动，为负数则表示向前(文件头)移动。 // ios::end 表示流的结束位置。此时 offset 应为非正整数 istream \u0026 seekg(long offset, ios::seek_dir dir); /* 2. 返回写指针当前位置的函数 */ // 函数返回值为流中读指针的当前位置。 long tellg(); **类 ostream **中与位置指针相关的函数如下:\n/* 1. 移动写指针函数 */ // 该函数的功能是将写指针设置为 pos，即将写指针移动到文件的 pos 字节处 ostream \u0026 seekp(long pos); // 该函数的功能是将写指针按 seek_dir 指示的方向移动 offset 个字节 ostream \u0026 seekp(long offset, ios::seek_dir dir); /* 2. 返回写指针当前位置的函数 */ // 函数的返回值为流中写指针的当前位置 long tellp(); 函数模板与类模板 函数模板 设计程序中的函数时，可能会遇到函数中参数的类型有差异，但需要实现的功能类似的情形。函数重载可以处理这种情形。重载函数的参数表中，可以写不同类型的参数，从而可以处理不同的情形。\n为了提高效率，实现代码复用，C++ 提供了一种处理机制，即使用函数模板。函数在设计时并不使用实际的类型，而是使用虚拟的类型参数。\n当用实际的类型来实例化这种函数时，将函数模板与某个具体数据类型连用。**编译器将以函数模板为样板，生成一个函数，即产生了模板函数，这个过程称为函数模板实例化。**函数模板实例化的过程由编译器完成。程序设计时并不给出相应数据的类型，编译时，由编译器根据实际的类型进行实例化。\n#include using namespace std; templatetypename T T abs(T x) { return x0?-x:x; } int main() { int n=-5; int m=10; double d=-.5; float f=3.2; coutn\"的绝对值是:\"abs(n)endl; coutm\"的绝对值是:\"abs(m)endl; coutd\"的绝对值是:\"abs(d)endl; coutf\"的绝对值是:\"abs(f )endl; return 0; } 函数与函数模板也是允许重载的。在函数和函数模板名字相同的情况下，一条函数调用语句到底应该被匹配成对哪个函数或哪个模板的调用呢?\nC++ 编译器遵循以下先后顺序：\n 先找参数完全匹配的普通函数(不是由模板实例化得到的模板函数)； 再找参数完全匹配的模板函数； 然后找实参经过自动类型转换后能够匹配的普通函数； 如果上面的都找不到，则报错。  类模板 通过类模板，可以实例化一个个的类。\n 继承机制也是在一系列的类之间建立某种联系，类是相同类型事物的抽象，有继承关系的类可以具有不同的操作。 模板是不同类型的事物具有相同的操作，实例化后的类之间没有联系，相互独立。  不能使用类模板来直接生成对象，因为类型参数是不确定的，必须先为模板参数指定“实参”，即模板要“实例化”后，才可以创建对象。也就是说，当使用类模板创建对象时，要随类模板名给出对应于类型形参或普通形参的具体实参。\n格式如下:\n  类模板名  对象名1,...,对象名n;\n  类模板名  对象名1(构造函数实参),...,对象名构造函数实参);\n  类模板中的成员函数全部都是模板函数。\n#includeusing namespace std; templateclass T class TestClass { public: T buffer[10]; T getData(int j); }; templateclass T T TestClassT::getData(int j) { return *(buffer+j); }; int main() { // char 取代 T，从而实例化为一个具体的类  TestClasschar ClassInstA; int i; char cArr[6]=\"abcde\"; for(i=0; i5; i++) { ClassInstA.buffer[i]=cArr[i]; } for(i=0; i5; i++) { char res = ClassInstA.getData(i); coutres\" \"; } coutendl; // 实例化为另外一个具体的类 double  TestClassdouble ClassInstF; fArr[6]={12.1,23.2,34.3,45.4,56.5,67.6}; for(i=0; i6; i++) { ClassInstF.buffer[i]=fArr[i]-10; } for(i=0; i6; i++) { double res = ClassInstF.getData(i); coutres\" \"; } coutendl; return 0; } 类之间允许继承，类模板之间也允许继承。具体来说，类模板和类模板之间、类模板和类之间可以互相继承，它们之间的常见派生关系有以下4种情况:\n 普通类继承模板类 类模板继承普通类 类模板继承类模板 类模板继承模板类。  根据类模板实例化的类即是模板类。\n#include  using namespace std; templateclass T class TBase { // 类模板，基类 \tT data; public: void print() { coutdataendl; } }; class Derived:public TBaseint {}; //从模板继承，普通类  int main() { Derived d; // 普通派生类的对象  d.print(); // 调用类模板中的成员函数  return 0; } ","wordCount":"18243","inLanguage":"en","datePublished":"2023-04-08T16:17:45+08:00","dateModified":"2023-04-08T16:17:45+08:00","author":[{"@type":"Person","name":"ABEE"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://abeelan.github.io/posts/read/c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"ABEE","logo":{"@type":"ImageObject","url":"https://abeelan.github.io/img/favicon.ico"}}}</script></head><body id=top><script>(function(){let a,b=new RegExp("(^| )change-themes=([^;]*)(;|$)");(a=document.cookie.match(b))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark')):(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://abeelan.github.io/ accesskey=h title="ABEE (Alt + H)"><img src=https://abeelan.github.io/img/avatar.gif alt=logo aria-label=logo height=35>ABEE</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://abeelan.github.io/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://abeelan.github.io/tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://abeelan.github.io/archives/ title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://abeelan.github.io/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li><li><a href=https://abeelan.github.io/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}body{counter-reset:h2}h2{counter-reset:h3}h3{counter-reset:h4}h4{counter-reset:h5}article[autonumbering] h2:before{counter-increment:h2;content:counter(h2)". "}article[autonumbering] h3:before{counter-increment:h3;content:counter(h2)"." counter(h3)" "}article[autonumbering] h4:before{counter-increment:h4;content:counter(h2)"." counter(h3)"." counter(h4)" "}article[autonumbering] .toc ul{counter-reset:item}article[autonumbering] .toc li a:before{content:counters(item,".")" ";counter-increment:item}</style><article class=post autonumbering><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://abeelan.github.io/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://abeelan.github.io/posts/>📚 分类</a>&nbsp;»&nbsp;<a href=https://abeelan.github.io/posts/read/>📕 阅读</a></div><h1 class=post-title>《C++程序设计》个人笔记</h1><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span><span>2023-04-08
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_3><span class="fa fa-file-word-o"></span><span>18243字
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_4><span class="fa fa-clock-o"></span><span>37分钟
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_5><span class="fa fa-user-o"></span><span>ABEE
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span><span><span class=post-tags-meta><a href=https://abeelan.github.io/tags/%E8%87%AA%E8%80%83/ style=color:var(--secondary)!important>自考</a></span></span></span></span>
<span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span><span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>&nbsp;&nbsp;</span></span>
<span id=post_meta_style_8><span class="fa fa-commenting-o"></span><span><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script><script>let url=document.documentURI,dnsUrl="https://abeelan.github.io/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=='/'&&(finalUrl='/'+finalUrl),twikoo.getCommentsCount({envId:null,region:"ap-beijing",urls:[finalUrl],includeReply:!1}).then(function(a){let b=a[0].count;const c=document.getElementById("comment_count");c.innerText=b}).catch(function(a){console.error(a)})</script><span id=comment_count></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80c-%e7%ae%80%e4%bb%8b aria-label="一、C++ 简介">一、C++ 简介</a><ul><ul><ul><li><a href=#1-%e5%a4%b4%e6%96%87%e4%bb%b6%e5%92%8c%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4 aria-label="1. 头文件和命名空间">1. 头文件和命名空间</a></li><li><a href=#2-%e5%9f%ba%e6%9c%ac%e7%9a%84%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba aria-label="2. 基本的输入/输出">2. 基本的输入/输出</a></li><li><a href=#3-%e5%bc%ba%e5%88%b6%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="3. 强制类型转换运算符">3. 强制类型转换运算符</a></li><li><a href=#4-%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0%e7%9a%84%e9%bb%98%e8%ae%a4%e5%80%bc aria-label="4. 函数参数的默认值">4. 函数参数的默认值</a></li><li><a href=#5-%e5%bc%95%e7%94%a8 aria-label="5. 引用">5. 引用</a></li><li><a href=#6-const-%e4%b8%8e%e6%8c%87%e9%92%88%e5%85%b1%e5%90%8c%e4%bd%bf%e7%94%a8 aria-label="6. const 与指针共同使用">6. const 与指针共同使用</a></li><li><a href=#7-%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0 aria-label="7. 内联函数">7. 内联函数</a></li><li><a href=#8-%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd aria-label="8. 函数重载">8. 函数重载</a></li><li><a href=#9-%e6%8c%87%e9%92%88%e5%92%8c%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d aria-label="9. 指针和动态内存分配">9. 指针和动态内存分配</a></li><li><a href=#10-string-%e5%af%b9%e8%b1%a1 aria-label="10. string 对象">10. string 对象</a></li><li><a href=#11-c-%e8%af%ad%e8%a8%80%e7%9a%84%e7%a8%8b%e5%ba%8f%e7%bb%93%e6%9e%84 aria-label="11. C++ 语言的程序结构">11. C++ 语言的程序结构</a></li></ul></ul></ul></li><li><a href=#%e4%ba%8c%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=二、面向对象的基本概念>二、面向对象的基本概念</a><ul><ul><li><a href=#1-%e7%b1%bb%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label="1. 类的定义">1. 类的定义</a></li><li><a href=#2-%e5%88%9b%e5%bb%ba%e7%b1%bb%e5%af%b9%e8%b1%a1%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%bd%a2%e5%bc%8f aria-label="2. 创建类对象的基本形式">2. 创建类对象的基本形式</a></li><li><a href=#3-%e8%ae%bf%e9%97%ae%e5%af%b9%e8%b1%a1%e7%9a%84%e6%88%90%e5%91%98 aria-label="3. 访问对象的成员">3. 访问对象的成员</a><ul><li><a href=#31-%e9%80%9a%e8%bf%87%e5%af%b9%e8%b1%a1%e8%ae%bf%e9%97%ae aria-label="3.1 通过对象访问">3.1 通过对象访问</a></li><li><a href=#32-%e9%80%9a%e8%bf%87%e6%8c%87%e9%92%88%e8%ae%bf%e9%97%ae aria-label="3.2 通过指针访问">3.2 通过指针访问</a></li><li><a href=#33-%e9%80%9a%e8%bf%87%e5%bc%95%e7%94%a8%e8%ae%bf%e9%97%ae aria-label="3.3 通过引用访问">3.3 通过引用访问</a></li></ul></li><li><a href=#4-%e6%a0%87%e8%af%86%e7%ac%a6%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%b8%8e%e5%8f%af%e8%a7%81%e6%80%a7 aria-label="4. 标识符的作用域与可见性">4. 标识符的作用域与可见性</a></li></ul></ul></li><li><a href=#%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1%e8%bf%9b%e9%98%b6 aria-label=类和对象进阶>类和对象进阶</a><ul><ul><li><a href=#1-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label="1. 构造函数">1. 构造函数</a><ul><li><a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=构造函数的作用>构造函数的作用</a></li><li><a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=构造函数的定义>构造函数的定义</a></li><li><a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=构造函数的使用>构造函数的使用</a></li><li><a href=#%e5%a4%8d%e5%88%b6%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=复制构造函数>复制构造函数</a></li></ul></li><li><a href=#2-%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0 aria-label="2. 析构函数">2. 析构函数</a></li><li><a href=#3-%e5%8f%98%e9%87%8f%e5%8f%8a%e5%af%b9%e8%b1%a1%e7%9a%84%e7%94%9f%e5%ad%98%e6%9c%9f%e5%92%8c%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label="3. 变量及对象的生存期和作用域">3. 变量及对象的生存期和作用域</a></li><li><a href=#4-%e7%b1%bb%e7%9a%84%e9%9d%99%e6%80%81%e6%88%90%e5%91%98 aria-label="4. 类的静态成员">4. 类的静态成员</a></li><li><a href=#5-%e5%b8%b8%e9%87%8f%e6%88%90%e5%91%98%e5%92%8c%e5%b8%b8%e5%bc%95%e7%94%a8%e6%88%90%e5%91%98 aria-label="5. 常量成员和常引用成员">5. 常量成员和常引用成员</a></li><li><a href=#6-%e6%88%90%e5%91%98%e5%af%b9%e8%b1%a1%e5%92%8c%e5%b0%81%e9%97%ad%e7%b1%bb aria-label="6. 成员对象和封闭类">6. 成员对象和封闭类</a></li><li><a href=#7-%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0 aria-label="7. 友元函数">7. 友元函数</a><ul><li><a href=#%e5%8f%8b%e5%85%83%e7%b1%bb aria-label=友元类>友元类</a></li></ul></li><li><a href=#8-this-%e6%8c%87%e9%92%88 aria-label="8. this 指针">8. this 指针</a></li></ul></ul></li><li><a href=#%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd aria-label=运算符重载>运算符重载</a><ul><ul><li><a href=#%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=运算符重载的概念>运算符重载的概念</a><ul><li><a href=#%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e8%a7%84%e5%88%99 aria-label=重载运算符的规则>重载运算符的规则</a></li><li><a href=#%e9%87%8d%e8%bd%bd%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=重载赋值运算符>重载赋值运算符</a></li><li><a href=#%e9%87%8d%e8%bd%bd%e6%b5%81%e6%8f%92%e5%85%a5%e8%bf%90%e7%ae%97%e7%ac%a6%e5%92%8c%e6%b5%81%e6%8f%90%e5%8f%96%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=重载流插入运算符和流提取运算符>重载流插入运算符和流提取运算符</a></li><li><a href=#%e9%87%8d%e8%bd%bd%e8%87%aa%e5%a2%9e%e8%87%aa%e5%87%8f%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=重载自增、自减运算符>重载自增、自减运算符</a></li></ul></li></ul></ul></li><li><a href=#%e7%b1%bb%e7%9a%84%e7%bb%a7%e6%89%bf%e4%b8%8e%e6%b4%be%e7%94%9f aria-label=类的继承与派生>类的继承与派生</a><ul><ul><li><a href=#%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6 aria-label=访问控制>访问控制</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e5%85%bc%e5%ae%b9%e8%a7%84%e5%88%99 aria-label=类型兼容规则>类型兼容规则</a><ul><li><a href=#%e6%b4%be%e7%94%9f%e7%b1%bb%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%8e%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0 aria-label=派生类的构造函数与析构函数>派生类的构造函数与析构函数</a></li><li><a href=#%e7%b1%bb%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=类之间的关系>类之间的关系</a></li><li><a href=#%e5%a4%9a%e5%b1%82%e6%ac%a1%e7%9a%84%e6%b4%be%e7%94%9f aria-label=多层次的派生>多层次的派生</a></li><li><a href=#%e5%9f%ba%e7%b1%bb%e4%b8%8e%e6%b4%be%e7%94%9f%e7%b1%bb%e6%8c%87%e9%92%88%e7%9a%84%e7%9b%b8%e4%ba%92%e8%bd%ac%e6%8d%a2 aria-label=基类与派生类指针的相互转换>基类与派生类指针的相互转换</a></li></ul></li></ul></ul></li><li><a href=#%e5%a4%9a%e6%80%81%e4%b8%8e%e8%99%9a%e5%87%bd%e6%95%b0 aria-label=多态与虚函数>多态与虚函数</a><ul><li><a href=#%e5%a4%9a%e6%80%81%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=多态的基本概念>多态的基本概念</a><ul><li><a href=#%e5%a4%9a%e6%80%81 aria-label=多态>多态</a></li><li><a href=#%e8%99%9a%e5%87%bd%e6%95%b0 aria-label=虚函数>虚函数</a></li><li><a href=#%e8%99%9a%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0 aria-label=虚析构函数>虚析构函数</a></li><li><a href=#%e7%ba%af%e8%99%9a%e5%87%bd%e6%95%b0 aria-label=纯虚函数>纯虚函数</a></li><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb aria-label=抽象类>抽象类</a></li><li><a href=#%e8%99%9a%e5%9f%ba%e7%b1%bb aria-label=虚基类>虚基类</a></li></ul></li></ul></li><li><a href=#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e6%b5%81 aria-label=输入/输出流>输入/输出流</a><ul><li><a href=#%e6%b5%81%e7%b1%bb%e7%ae%80%e4%bb%8b aria-label=流类简介>流类简介</a></li></ul></li><li><a href=#iostream-%e7%b1%bb%e5%ba%93 aria-label="iostream 类库">iostream 类库</a><ul><li><a href=#iostream aria-label=iostream>iostream</a><ul><li><a href=#iomanip aria-label=iomanip>iomanip</a><ul><li><a href=#%e6%b5%81%e6%93%8d%e7%ba%b5%e7%ac%a6 aria-label=流操纵符>流操纵符</a></li><li><a href=#%e6%a0%87%e5%bf%97%e5%ad%97 aria-label=标志字>标志字</a></li></ul></li><li><a href=#%e8%b0%83%e7%94%a8-cout-%e7%9a%84%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0 aria-label="调用 cout 的成员函数">调用 cout 的成员函数</a></li><li><a href=#%e8%b0%83%e7%94%a8-cin-%e7%9a%84%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0 aria-label="调用 cin 的成员函数">调用 cin 的成员函数</a></li></ul></li></ul></li><li><a href=#%e6%96%87%e4%bb%b6%e5%92%8c%e6%93%8d%e4%bd%9c aria-label=文件和操作>文件和操作</a><ul><ul><li><a href=#%e6%96%87%e4%bb%b6%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5%e5%92%8c%e6%96%87%e4%bb%b6%e6%b5%81%e7%b1%bb aria-label=文件基本概念和文件流类>文件基本概念和文件流类</a></li><li><a href=#%e6%89%93%e5%bc%80%e5%92%8c%e5%85%b3%e9%97%ad%e6%96%87%e4%bb%b6 aria-label=打开和关闭文件>打开和关闭文件</a></li><li><a href=#%e6%96%87%e4%bb%b6%e8%af%bb%e5%86%99%e6%93%8d%e4%bd%9c aria-label=文件读写操作>文件读写操作</a><ul><li><a href=#%e8%af%bb%e5%86%99%e6%96%87%e6%9c%ac%e6%96%87%e4%bb%b6 aria-label=读写文本文件>读写文本文件</a></li><li><a href=#%e8%af%bb%e5%86%99%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6 aria-label=读写二进制文件>读写二进制文件</a></li><li><a href=#%e7%94%a8%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0-put-%e5%92%8c-get-%e8%af%bb%e5%86%99%e6%96%87%e4%bb%b6 aria-label="用成员函数 put() 和 get() 读写文件">用成员函数 put() 和 get() 读写文件</a></li><li><a href=#%e6%96%87%e6%9c%ac%e6%96%87%e4%bb%b6%e4%b8%8e%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6%e5%bc%82%e5%90%8c aria-label=文本文件与二进制文件异同>文本文件与二进制文件异同</a></li></ul></li><li><a href=#%e9%9a%8f%e6%9c%ba%e8%ae%bf%e9%97%ae%e6%96%87%e4%bb%b6 aria-label=随机访问文件>随机访问文件</a></li></ul></ul></li><li><a href=#%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e4%b8%8e%e7%b1%bb%e6%a8%a1%e6%9d%bf aria-label=函数模板与类模板>函数模板与类模板</a><ul><ul><li><a href=#%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf aria-label=函数模板>函数模板</a></li><li><a href=#%e7%b1%bb%e6%a8%a1%e6%9d%bf aria-label=类模板>类模板</a></li></ul></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener('DOMContentLoaded',function(b){checkTocPosition(),elements=document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]'),activeElement=elements[0];const a=encodeURI(activeElement.getAttribute('id')).toLowerCase();document.querySelector(`.inner ul li a[href="#${a}"]`).classList.add('active')},!1),window.addEventListener('resize',function(a){checkTocPosition()},!1),window.addEventListener('scroll',()=>{activeElement=Array.from(elements).find(a=>{if(getOffsetTop(a)-window.pageYOffset>0&&getOffsetTop(a)-window.pageYOffset<window.innerHeight/2)return a})||activeElement,elements.forEach(a=>{const b=encodeURI(a.getAttribute('id')).toLowerCase();a===activeElement?document.querySelector(`.inner ul li a[href="#${b}"]`).classList.add('active'):document.querySelector(`.inner ul li a[href="#${b}"]`).classList.remove('active')})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue('--gap'),10);function checkTocPosition(){const a=document.body.scrollWidth;a-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(a){if(!a.getClientRects().length)return 0;let b=a.getBoundingClientRect(),c=a.ownerDocument.defaultView;return b.top+c.pageYOffset}</script><div class=post-content><h2 id=一c-简介>一、C++ 简介<a hidden class=anchor aria-hidden=true href=#一c-简介>#</a></h2><p>程序设计语言分为：</p><ul><li><strong>低级语言</strong>（机器语言、汇编语言）</li><li>中级语言</li><li><strong>高级语言</strong>（C、C++等）</li></ul><p>C++ 语言的主要特点：</p><ul><li><strong>兼容</strong> C 语言</li><li>面向对象（继承和多态）</li><li>引进了类和对象的概念</li></ul><p><strong>C++ 的基本数据类型</strong></p><ul><li>bool：布尔值</li><li>char：字符型</li><li>int：整型</li><li>float：浮点型</li><li>double：双精度浮点型</li></ul><p>注释的两种方式：</p><ul><li>单行注释（<code>//</code>）</li><li>多行注释（<code>/*..*/</code>）</li></ul><p>编写 C++ 程序一般需要经过四个步骤，依次是：编辑、编译、连接、运行。</p><h5 id=1-头文件和命名空间>1. 头文件和命名空间<a hidden class=anchor aria-hidden=true href=#1-头文件和命名空间>#</a></h5><p>包含头文件需要使用 <code># include</code> 指令，一条指令<strong>仅</strong>可以包含一个头文件，多个头文件需要使用多条指令。</p><p>通常使用尖括号 <code>&lt;></code> 包含系统头文件，会首先在系统设定的目录中寻找要包含的头文件；</p><p>使用双引号 <code>""</code> 包含自定义的头文件，会在当前用户目录下或指令中指定的目录下寻找要包含的头文件。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e># include &lt;iostream&gt;
</span><span style=color:#75715e># include &#34;myCustom.h&#34;
</span></code></pre></div><p>常用的头文件：</p><ul><li>标准输入/输出流：<code>&lt;iostream></code></li><li>标准文件流：<code>&lt;fstream></code></li><li>标准字符串处理函数：<code>&lt;string></code></li><li>标准数学函数：<code>&lt;cmath></code></li></ul><p>文件后缀 <code>.cpp</code> 是源程序文件，文件后缀 <code>.h</code> 是头文件。</p><p><strong>命名空间</strong>的作用是消除同名引起的歧义。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#75715e>// 自定义命名空间
</span><span style=color:#75715e></span><span style=color:#66d9ef>namespace</span> work {  <span style=color:#75715e>// work 为命名空间名
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 各种声明
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span> {...};  
    func() {...};
};

<span style=color:#75715e>// 使用方式一
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> work<span style=color:#f92672>::</span>func();

<span style=color:#75715e>// 使用方式二 推荐
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> work;
Foo f;  <span style=color:#75715e>// 文件头声明后后面可以直接使用
</span><span style=color:#75715e></span>func();
</code></pre></div><h5 id=2-基本的输入输出>2. 基本的输入/输出<a hidden class=anchor aria-hidden=true href=#2-基本的输入输出>#</a></h5><p>当程序需要进行输入/输出信息时，需要包含头文件 <strong><iostream></strong></p><ul><li><p><strong>cin</strong>：使用<strong>流提取</strong>运算符 <strong>&#187;</strong> 从标准输入设备<strong>键盘</strong>取得数据；</p></li><li><p><strong>cout</strong>：使用<strong>流插入</strong>运算符 <strong>&#171;</strong> 向标准输入设备<strong>屏幕</strong>输出信息。</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e># include &lt;iostream&gt;
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>int</span> a, b;
    cin<span style=color:#f92672>&gt;&gt;</span>a<span style=color:#f92672>&gt;&gt;</span>b;
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;a=&#34;</span><span style=color:#f92672>&lt;&lt;</span>a<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>b=&#34;</span><span style=color:#f92672>&lt;&lt;</span>b<span style=color:#f92672>&lt;&lt;</span>endl;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h5 id=3-强制类型转换运算符>3. 强制类型转换运算符<a hidden class=anchor aria-hidden=true href=#3-强制类型转换运算符>#</a></h5><p>static_cast 把表达式类型转换为类型名所指定的类型，static_cast 也可以省略。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>double</span> num <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.12</span>;
n1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(num);  <span style=color:#75715e>// 强制类型转换
</span><span style=color:#75715e></span>n2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(num);               <span style=color:#75715e>// 强制类型转换运算符的新形式
</span><span style=color:#75715e></span>n3 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span>) num;              <span style=color:#75715e>// 强制类型转换运算符的旧形式
</span><span style=color:#75715e></span>n4 <span style=color:#f92672>=</span> num;                    <span style=color:#75715e>// 自动类型转换
</span></code></pre></div><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/abeelan/image-hosting-service/img/image-20230321222251985.png alt=image-20230321222251985></p><h5 id=4-函数参数的默认值>4. 函数参数的默认值<a hidden class=anchor aria-hidden=true href=#4-函数参数的默认值>#</a></h5><p>C++ 语言规定，提供默认值必须按<strong>从右至左</strong>的顺序提供，有默认值的形参必须在最后。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>int</span> c<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>);  <span style=color:#75715e>// 正确
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(<span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>int</span> b);  <span style=color:#75715e>// 错误，a 有默认值形参应该放在最后
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>int</span> c); <span style=color:#75715e>// 错误，b 有默认形参应该放在最后
</span></code></pre></div><p>调用函数时，主调函数的实参与被调函数的形参按<strong>从左至右</strong>的顺序进行匹配对应。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>func</span>(<span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>char</span> y<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;$&#39;</span>, <span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>9</span>, <span style=color:#66d9ef>char</span> b<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;@&#39;</span>);

<span style=color:#75715e>// 函数调用判断
</span><span style=color:#75715e></span>func(<span style=color:#ae81ff>3.14</span>);  <span style=color:#75715e>// 正确，仅匹配 x，其他都有默认值
</span><span style=color:#75715e></span>func(<span style=color:#ae81ff>3.14</span>, <span style=color:#e6db74>&#39;#&#39;</span>);  <span style=color:#75715e>// 正确，匹配 x、y 
</span><span style=color:#75715e></span>func(<span style=color:#ae81ff>3.14</span>, <span style=color:#e6db74>&#39;%&#39;</span>, <span style=color:#e6db74>&#39;@&#39;</span>);  <span style=color:#75715e>// 错误，第三个参数类型不对应，预期 int，实际是 char
</span><span style=color:#75715e></span>func(<span style=color:#ae81ff>3.14</span>, <span style=color:#e6db74>&#39;&amp;&#39;</span>, <span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#39;*&#39;</span>);  <span style=color:#75715e>// 正确
</span><span style=color:#75715e></span>func(<span style=color:#ae81ff>3.14</span>, , <span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#39;*&#39;</span>);  <span style=color:#75715e>// 错误，调用时的实参应该是连续排列的
</span></code></pre></div><h5 id=5-引用>5. 引用<a hidden class=anchor aria-hidden=true href=#5-引用>#</a></h5><p><strong>引用</strong>相当于给变量起了个<strong>别名</strong>，对应于某个<strong>内存地址</strong>。如果给某个变量起了别名（不需要给它另开辟内存单元），相当于变量和这个引用都对应到<strong>同一地址</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#75715e>// 在程序中定义变量的引用
</span><span style=color:#75715e>// 类型名 &amp;引用名 = 同类型的某变量名;
</span><span style=color:#75715e></span><span style=color:#75715e># include &lt;iostream&gt;
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>int</span> foo <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ref <span style=color:#f92672>=</span> foo;  <span style=color:#75715e>// ref 是 foo 的引用，等价于 foo
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ref2 <span style=color:#f92672>=</span> foo;  <span style=color:#75715e>// 定义常引用
</span><span style=color:#75715e></span>    
    ref <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;  <span style=color:#75715e>// foo=2; ref=2; ref2=2;
</span><span style=color:#75715e></span>    foo <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;  <span style=color:#75715e>// foo=3; ref=3; ref2=3;
</span><span style=color:#75715e></span>    <span style=color:#75715e>// ref2 = 4;  错误，不能使用常引用对所引用的变量进行修改
</span><span style=color:#75715e></span>    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>引用还可以用在函数中，既可以作为函数的<strong>参数</strong>使用，也可以作为函数的<strong>返回值</strong>使用。函数调用时参数的传递方式有两种：<strong>传值</strong>和<strong>传引用</strong>。</p><p>传值，传递对象的<strong>值</strong>。将实参的值拷贝给形参，函数执行过程中，都是对这个拷贝进行操作的，执行完毕后，形参的值并不拷贝回实参。也就是函数内部对形参的改变<strong>不会影响</strong>到函数外实参的值。</p><p>传引用，传递对象的<strong>首地址值</strong>。函数调用时，实参对象名传递给形参对象名，形参就成为实参的引用，他们是等价的，代表同一个对象。也可以看作是将实参的地址传递给了形参，函数内部对形参进行的改变，<strong>会影响</strong>到函数外实参的值。引用调用<strong>形参</strong>必须是引用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 函数中使用引用
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* 例 1：引用作为参数传递 */</span>
<span style=color:#75715e># include &lt;iostream&gt;
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {  <span style=color:#75715e>// 传值
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> tmp;
    tmp <span style=color:#f92672>=</span> x; x <span style=color:#f92672>=</span> y; y <span style=color:#f92672>=</span> tmp;
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;func(): &#34;</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;a=&#34;</span><span style=color:#f92672>&lt;&lt;</span>x<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; b=&#34;</span><span style=color:#f92672>&lt;&lt;</span>y<span style=color:#f92672>&lt;&lt;</span>endl;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func_ref</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>x, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>y) {  <span style=color:#75715e>// 传引用
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> tmp;
    tmp <span style=color:#f92672>=</span> x; x <span style=color:#f92672>=</span> y; y <span style=color:#f92672>=</span> tmp;
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;func_ref(): &#34;</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;a=&#34;</span><span style=color:#f92672>&lt;&lt;</span>x<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; b=&#34;</span><span style=color:#f92672>&lt;&lt;</span>y<span style=color:#f92672>&lt;&lt;</span>endl;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
    
    func(a, b);
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;调用 func() 后: a=&#34;</span><span style=color:#f92672>&lt;&lt;</span>a<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; b=&#34;</span><span style=color:#f92672>&lt;&lt;</span>b<span style=color:#f92672>&lt;&lt;</span>endl;
    <span style=color:#75715e>// func(): a=20 b=10
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 调用 func() 后: a=10 b=20
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 形参的改变没有影响函数外实参的值
</span><span style=color:#75715e></span>    
    func_ref(a, b);
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;调用 func_ref() 后: a=&#34;</span><span style=color:#f92672>&lt;&lt;</span>a<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; b=&#34;</span><span style=color:#f92672>&lt;&lt;</span>b<span style=color:#f92672>&lt;&lt;</span>endl;
    <span style=color:#75715e>// func_ref(): a=20 b=10
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 调用 func_ref() 后: a=20 b=10
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 形参的改变影响了函数外实参的值
</span><span style=color:#75715e></span>    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#75715e>/* 例 2：引用作为返回值 */</span>
<span style=color:#75715e># include &lt;iostream&gt;
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;

<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ref(<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>x) {  <span style=color:#75715e>// 返回值是引用
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> x;  
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    ref(a) <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>;
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;a=&#34;</span><span style=color:#f92672>&lt;&lt;</span>a<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; b=&#34;</span><span style=color:#f92672>&lt;&lt;</span>b<span style=color:#f92672>&lt;&lt;</span>endl;   <span style=color:#75715e>// a=30 b=20
</span><span style=color:#75715e></span>    
    ref(b) <span style=color:#f92672>=</span> <span style=color:#ae81ff>40</span>;
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;a=&#34;</span><span style=color:#f92672>&lt;&lt;</span>a<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; b=&#34;</span><span style=color:#f92672>&lt;&lt;</span>b<span style=color:#f92672>&lt;&lt;</span>endl;  <span style=color:#75715e>// a=30 b=40
</span><span style=color:#75715e></span>    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h5 id=6-const-与指针共同使用>6. const 与指针共同使用<a hidden class=anchor aria-hidden=true href=#6-const-与指针共同使用>#</a></h5><blockquote><p>const 用于约束某值<strong>不变</strong>，在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// const 修饰普通变量
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
<span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> a;  <span style=color:#75715e>// 正确
</span><span style=color:#75715e></span>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;  <span style=color:#75715e>// 错误 不能改变
</span><span style=color:#75715e>// a 被定义为一个常量
</span><span style=color:#75715e>// 可以将 a 赋值给 b，但是不能对 a 再次赋值，不允许对常量重新赋值
</span></code></pre></div><p><strong>const 修饰指针变量</strong></p><blockquote><p>情况一：左定值，const 修饰指针指向的内容，则内容为不可变量。</p></blockquote><p><code>const int *p = 8;</code></p><p>如果唯一的 <code>const</code> 位于符号 <code>*</code> 的左侧，表示指针所指数据是常量，数据不能通过本指针改变，但可以通过其他方式修改。指针本身是变量，可以指向其他的内存单元。</p><blockquote><p>情况二：右定向，const 指针指向的内存地址不能被改变，但其内容可以改变。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>a;
<span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>;  <span style=color:#75715e>// 正确，内容可改变
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>b;  <span style=color:#75715e>// 错误，指针地址不能被改变
</span></code></pre></div><p>如果唯一的 <code>const</code> 位于符号 <code>*</code> 的右侧，表示指针本身是常量，不能让该指针指向其他内存地址。指针所指的数据可以通过本指针进行修改。</p><blockquote><p>情况三：内容和指针内存地址都固定，不可改变。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>a;
<span style=color:#66d9ef>int</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>a;
</code></pre></div><p>如果在 <code>*</code> 的左右各有一个 <code>const</code> 时，表示指针和指针所指的数据都是常量，既不能让指针指向其他地址，也不能通过指针修改所指向的内容。</p><h5 id=7-内联函数>7. 内联函数<a hidden class=anchor aria-hidden=true href=#7-内联函数>#</a></h5><p>为避免频繁的函数调用，使用内联函数，在编译时不生成函数调用，而是将程序中出现的每一个内联函数表达式替换为该内联函数的函数体。使用内联函数会使最终可执行程序的体积增大，以空间消耗节省时间开销。</p><p>定义内联函数需要在函数头加上关键字 <code>inline</code>，定义在前，调用在后。内联函数主要应用于<code>代码量少且频繁调用的函数</code>，通常不建议内联函数体中包含循环语句或 <code>switch</code> 语句。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#75715e># include &lt;iostream&gt;
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Max</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>&gt;</span> y <span style=color:#f92672>?</span> x : y;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    cout<span style=color:#f92672>&lt;&lt;</span>Max(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>10</span>)<span style=color:#f92672>&lt;&lt;</span>endl;
    cout<span style=color:#f92672>&lt;&lt;</span>Max(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>500</span>)<span style=color:#f92672>&lt;&lt;</span>endl;
}
</code></pre></div><p>如果函数成员定义在类体内，则默认是内联函数。也可以在类体内部声明函数，并加上 <code>inline</code> 关键字，然后在类体外给出定义，这样也是内联函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e># include &lt;iostream&gt;
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> print1();  <span style=color:#75715e>// 类体外定义需要加 inline 关键字
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print2</span>() {  <span style=color:#75715e>// 默认内联函数
</span><span style=color:#75715e></span>            cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;print inline 2&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
        }
};

<span style=color:#66d9ef>void</span> A<span style=color:#f92672>::</span>print1() {
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;print inline 1&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    A a;
    a.print1();
    a.print2();
}
</code></pre></div><h5 id=8-函数重载>8. 函数重载<a hidden class=anchor aria-hidden=true href=#8-函数重载>#</a></h5><p>函数重载是指在程序的同一范围内声明几个功能类似的<strong>同名函数</strong>，提高代码<strong>可读性</strong>。必须要满足条件之一：</p><ul><li>参数表中<strong>参数类型不同</strong>（顺序不同也可）</li><li>参数表中<strong>参数个数不同</strong></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e># include &lt;iostream&gt;
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>&gt;</span> y <span style=color:#f92672>?</span> x : y;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>float</span> y) {
    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>&gt;</span> y <span style=color:#f92672>?</span> x : y;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    cout<span style=color:#f92672>&lt;&lt;</span>max(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>8</span>)<span style=color:#f92672>&lt;&lt;</span>endl;
    cout<span style=color:#f92672>&lt;&lt;</span>max(<span style=color:#ae81ff>3.14</span>, <span style=color:#ae81ff>5.67</span>)<span style=color:#f92672>&lt;&lt;</span>endl;
}
</code></pre></div><p>如果两个函数的名字和参数表都是一样的，<strong>仅仅是返回值类型不同</strong>，则不符合函数重载的条件，编译报错。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 错误的函数重载
</span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>float</span> y);
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span> (<span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>float</span> y);
</code></pre></div><p>采用<strong>引用参数</strong>也不符合函数重载。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 错误的函数重载
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>(<span style=color:#66d9ef>double</span>);
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>double</span>);
</code></pre></div><p>避免产生<strong>二义性</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 错误的函数重载
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>);
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b);

sum(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);  <span style=color:#75715e>// 编译错误，不知道调用哪个函数
</span></code></pre></div><h5 id=9-指针和动态内存分配>9. 指针和动态内存分配<a hidden class=anchor aria-hidden=true href=#9-指针和动态内存分配>#</a></h5><p>C++ 中使用 <code>new</code> 运算符实现动态内存分配。指针变量中保存的是一个地址，也称指针指向一个地址。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p;
p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>;  <span style=color:#75715e>// 动态分配 4 字节的内存空间
</span><span style=color:#75715e></span><span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</code></pre></div><p>使用 <code>new</code> 运算符也可以动态分配一个任意大小的数组。数组的长度是声明数组时指定的，不允许定义元素个数<strong>不明确</strong>的数组。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> pArr;
<span style=color:#66d9ef>int</span> n;
pArr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[n];  <span style=color:#75715e>// 错误，元素个数不明确
</span><span style=color:#75715e></span>pArr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>5</span>];  <span style=color:#75715e>// 分配了 5 个元素的整型数组
</span><span style=color:#75715e></span>pArr[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;  <span style=color:#75715e>// 数组的第一个值
</span><span style=color:#75715e></span>pArr[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;  <span style=color:#75715e>// 数组的最后一个值
</span></code></pre></div><p>使用 <code>pArr[-1]</code> 或者 <code>pArr[5]</code>时，下标会越界。不过在编译时，对于数组越界的错误不会提示，运行时报错。</p><p>使用 <code>new</code> 运算符动态申请的内存空间，需要在使用完毕后释放。使用 <code>delete</code> 运算符，用来释放动态分配的内存空间。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>/* 释放指针变量动态内存 */</span>
<span style=color:#66d9ef>int</span> foo <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;
<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>foo;
<span style=color:#66d9ef>delete</span> p;  <span style=color:#75715e>// 错误，delete 后面的指针必须是指向动态分配的内存空间（new）
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>q <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>;
<span style=color:#f92672>*</span>q <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
<span style=color:#66d9ef>delete</span> q;  <span style=color:#75715e>// 正确，q 指向动态分配的空间
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* 释放数组动态内存 */</span>
<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>100</span>];
<span style=color:#66d9ef>delete</span> []p;
</code></pre></div><h5 id=10-string-对象>10. string 对象<a hidden class=anchor aria-hidden=true href=#10-string-对象>#</a></h5><p>C++ 标准模板库中提供了 <code>string</code> 数据类型，专门处理字符串。<code>string</code> 是一个类，这个类型的变量称为 <code>string 对象</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e># include &lt;string&gt;  </span><span style=color:#75715e>// 需包含头文件
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 使用 string 类型初始化变量
</span><span style=color:#75715e></span>string str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;
string str2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;world&#34;</span>;

<span style=color:#75715e>// 使用字符数组对 string 变量初始化
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> name[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello, world.&#34;</span>;
string str <span style=color:#f92672>=</span> name;

<span style=color:#75715e>// 声明 string 对象数组
</span><span style=color:#75715e></span>string citys[] <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;beijing&#34;</span>, <span style=color:#e6db74>&#34;shenzhen&#34;</span>, <span style=color:#e6db74>&#34;shanghai&#34;</span>};

str.empty()           <span style=color:#75715e>// 判断字符串是否为空 true false
</span><span style=color:#75715e></span>str.length()          <span style=color:#75715e>// 返回字符串长度
</span><span style=color:#75715e></span>str.size()            <span style=color:#75715e>// 返回字符串占用空间字节数
</span><span style=color:#75715e></span>str.append(<span style=color:#e6db74>&#34;haha&#34;</span>)    <span style=color:#75715e>// 向字符串后面追加内容
</span><span style=color:#75715e></span>str.insert(<span style=color:#ae81ff>4</span>, <span style=color:#e6db74>&#34;123&#34;</span>)  <span style=color:#75715e>// 从字符串第四个位置插入内容
</span></code></pre></div><p><code>string</code> 对象间可以相互赋值，不需要考虑空间是否足够的问题。</p><h5 id=11-c-语言的程序结构>11. C++ 语言的程序结构<a hidden class=anchor aria-hidden=true href=#11-c-语言的程序结构>#</a></h5><p>C++程序以 <strong>.cpp</strong> 作为文件扩展名，文件中包含若干个类和若干个函数。程序中必须<strong>有且仅有一个主函数 main()</strong>，这是程序执行的总入口。程序<strong>从主函数</strong>的开始处执行，直到结束。主函数可以出现在任何地方。</p><p>程序的结束通常是遇到了以下两种情况：</p><ul><li>主函数中遇到了 <code>return</code> 语句</li><li>执行到了主函数最后的括号</li></ul><p>主函数可以调用其他函数，但其他函数不能调用主函数。主函数仅是系统执行程序时调用的。</p><h2 id=二面向对象的基本概念>二、面向对象的基本概念<a hidden class=anchor aria-hidden=true href=#二面向对象的基本概念>#</a></h2><p><strong>结构化程序设计方法</strong>采用<strong>自顶向下、逐步求精及模块化</strong>思想，大问题化小问题。</p><p>编写程序时使用 3 种基本控制结构：<strong>顺序、选择、循环</strong>，强调程序的易读性。</p><p><strong>面向对象程序设计方法</strong>就是使分析、设计和实现一个系统的方法 尽可能地接近 人们认识一个系统的方法。通常包括三方面：<strong>面向对象的分析、面向对象的设计、面向对象的程序设计</strong>。</p><p>对象具有两个特性：</p><ul><li><strong>状态</strong>，指对象本身的信息（属性）；</li><li><strong>行为</strong>，指对对象的操作。</li></ul><p>通过对实物的抽象找出同一类对象的共同<strong>属性（静态特征）<strong>和</strong>行为（动态特征）</strong>，从而得到类的概念。对象是类的一个具象，类是对象的一个抽象。C++ 中使用 <strong>对象名、属性、操作</strong> 三要素来描述对象。</p><p>面向对象的程序设计有四个基本特点：</p><ul><li><p><strong>抽象</strong>：对象的<strong>属性和操作</strong>；</p></li><li><p><strong>封装</strong>：通过自定义类来支持<strong>数据封装和信息隐藏</strong>；</p></li><li><p><strong>继承</strong>：在已有类的基础上加上特殊的数据和函数构成新类，原来的类是<strong>基类（父类或超类）</strong>，新类是<strong>派生类（子类）</strong>；</p></li><li><p><strong>多态</strong> ：不同种类的对象具有名称相同的行为，但具体的实现方式却不同。通过<strong>函数重载及运算符重载</strong>实现的多态。</p></li></ul><h4 id=1-类的定义>1. 类的定义<a hidden class=anchor aria-hidden=true href=#1-类的定义>#</a></h4><p>类是具有<strong>唯一标识符</strong>的实体，<strong>类名不能重复</strong>。</p><p>标识符命名规则：<strong>字母、数字、下划线</strong> 的组合，但不能以数字开头，<strong>大小写敏感</strong>，不能和系统中的关键字重名。类定义以 <code>;</code> 结束，大括号中的部分称为类体。</p><p>定义类时系统并<strong>不为类分配存储空间</strong>，类中声明的任何成员不能使用 <code>auto、extern、register</code> 关键字进行修饰。</p><p>类中的成员按功能划分：</p><ul><li><strong>成员变量</strong>：对象的<strong>属性</strong>，个数不限，也称为数据成员。成员变量的声明方式与普通变量的声明方式相同；</li><li><strong>成员函数</strong>：对象的<strong>操作</strong>，个数不限，声明方式与普通函数相同。</li></ul><p>类中的成员按访问权限划分：</p><ul><li><strong>公有成员(public)</strong>：公有的，可以在程序任何地方访问；</li><li><strong>私有成员(private)</strong> ：私有的，仅能在本类内访问；未定义则<strong>默认</strong>为私有；</li><li><strong>保护成员(protected)</strong>：保护的，能在本类内及子类中被访问。</li></ul><p>成员函数可以定义在类体内，也可以定义在类体外。可以定义不是任何类的成员的函数，称为<strong>全局函数</strong>。</p><p>如果成员函数定义在类体外，则类体内必须要有函数原型声明，类体外定义函数必须使用类作用域运算符 <code>::</code>。成员函数在内存中只有一份，可以作用于不同的对象，为类中各对象<strong>共享</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
    <span style=color:#66d9ef>int</span> foo <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 定义成员变量，默认为私有成员
</span><span style=color:#75715e></span>    
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>  <span style=color:#75715e>// 共有成员
</span><span style=color:#75715e></span>    	<span style=color:#66d9ef>void</span> print();  <span style=color:#75715e>// 类体内声明成员函数
</span><span style=color:#75715e></span>    	A a;  <span style=color:#75715e>// 错误，不能定义本类的成员变量
</span><span style=color:#75715e></span>};  <span style=color:#75715e>// 注意类定义最后要加引号
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> A<span style=color:#f92672>::</span>print() {};  <span style=color:#75715e>// 类体外定义成员函数
</span></code></pre></div><h4 id=2-创建类对象的基本形式>2. 创建类对象的基本形式<a hidden class=anchor aria-hidden=true href=#2-创建类对象的基本形式>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> {
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    	Test();
    	Test(<span style=color:#66d9ef>int</span> x);
};

<span style=color:#75715e>/* 方法一 */</span>
Test t1;            <span style=color:#75715e>// 类名 对象名;
</span><span style=color:#75715e></span>Test <span style=color:#a6e22e>t2</span>(<span style=color:#ae81ff>5</span>);         <span style=color:#75715e>// 类名 对象名(参数);
</span><span style=color:#75715e></span>Test t3 <span style=color:#f92672>=</span> Test(<span style=color:#ae81ff>6</span>);  <span style=color:#75715e>// 类名 对象名 = 类名(参数);
</span><span style=color:#75715e></span>Test t4, t5, t6(<span style=color:#ae81ff>7</span>), t7(<span style=color:#ae81ff>10</span>);  <span style=color:#75715e>// 扩展多个对象
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* 方法二 */</span>
Test <span style=color:#f92672>*</span>p1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Test;     <span style=color:#75715e>// 类名 *对象指针名 = new 类名;
</span><span style=color:#75715e></span>Test <span style=color:#f92672>*</span>p2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Test();   <span style=color:#75715e>// 类名 *对象指针名 = new 类名();
</span><span style=color:#75715e></span>Test <span style=color:#f92672>*</span>p3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Test(<span style=color:#ae81ff>5</span>);  <span style=color:#75715e>// 类名 *对象指针名 = new 类名(参数);
</span></code></pre></div><p>用 <code>new</code> 创建对象时返回的是一个对象指针，指向创建的对象。创建的对象必须用 <code>delete</code> 来撤销。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 声明对象的引用
</span><span style=color:#75715e></span>Test t1, t2;    <span style=color:#75715e>// 定义对象
</span><span style=color:#75715e></span>Test <span style=color:#f92672>&amp;</span>t <span style=color:#f92672>=</span> t1;  <span style=color:#75715e>// 声明对象的引用 ==&gt; 类名 &amp;对象引用名 = 对象;
</span><span style=color:#75715e></span>Test <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>t2;  <span style=color:#75715e>// 声明对象指针  ==&gt; 类名 *对象指针名 = 对象的地址;
</span><span style=color:#75715e></span>Test ts[<span style=color:#ae81ff>3</span>];     <span style=color:#75715e>// 声明对象数组  ==&gt; 类名 对象数组名[数组大小];
</span></code></pre></div><h4 id=3-访问对象的成员>3. 访问对象的成员<a hidden class=anchor aria-hidden=true href=#3-访问对象的成员>#</a></h4><p>定义了类对象后，就可以访问对象的成员。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> {
    <span style=color:#66d9ef>int</span> age;
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>char</span> msg[<span style=color:#ae81ff>40</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;该学生年龄为：&#34;</span>;
        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>();
        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span>(<span style=color:#66d9ef>int</span>);
};

<span style=color:#66d9ef>int</span> Student<span style=color:#f92672>::</span>getAge() {
    <span style=color:#66d9ef>return</span> age;
}

<span style=color:#66d9ef>void</span> Student<span style=color:#f92672>::</span>setAge(<span style=color:#66d9ef>int</span> x) {
    age <span style=color:#f92672>=</span> x;
}
</code></pre></div><h5 id=31-通过对象访问>3.1 通过对象访问<a hidden class=anchor aria-hidden=true href=#31-通过对象访问>#</a></h5><ul><li>对象名.成员变量名</li><li>对象名.成员函数名(参数表)</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Student s;
    s.setAge(<span style=color:#ae81ff>18</span>);  <span style=color:#75715e>// 成员函数 
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>s.msg;   <span style=color:#75715e>// 成员变量
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>s.getAge()<span style=color:#f92672>&lt;&lt;</span>endl; 
    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h5 id=32-通过指针访问>3.2 通过指针访问<a hidden class=anchor aria-hidden=true href=#32-通过指针访问>#</a></h5><p>还可以使用指针或引用的方式来访问类成员，运算符 <code>.</code> 需要更换为 <code>-></code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Student s;
    Student <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s;
    p <span style=color:#f92672>-&gt;</span> setAge(<span style=color:#ae81ff>19</span>);
    cout<span style=color:#f92672>&lt;&lt;</span>p<span style=color:#f92672>-&gt;</span>msg;
    cout<span style=color:#f92672>&lt;&lt;</span>p<span style=color:#f92672>-&gt;</span>getAge()<span style=color:#f92672>&lt;&lt;</span>endl;

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h5 id=33-通过引用访问>3.3 通过引用访问<a hidden class=anchor aria-hidden=true href=#33-通过引用访问>#</a></h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 与通过对象访问方式一样
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Student s;
    Student <span style=color:#f92672>&amp;</span>sr <span style=color:#f92672>=</span> s;
    sr.setAge(<span style=color:#ae81ff>20</span>);
    cout<span style=color:#f92672>&lt;&lt;</span>sr.msg;
    cout<span style=color:#f92672>&lt;&lt;</span>sr.getAge()<span style=color:#f92672>&lt;&lt;</span>endl;
    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h4 id=4-标识符的作用域与可见性>4. 标识符的作用域与可见性<a hidden class=anchor aria-hidden=true href=#4-标识符的作用域与可见性>#</a></h4><p>标识符是组成程序的最小成分之一。<strong>类名、函数名、变量名、常量名和枚举类型的取值</strong>等都是标识符。</p><p>标识符的作用域有：</p><ul><li><strong>函数原型作用域</strong>：函数声明时的形参，这是最小的作用域；</li><li><strong>局部作用域(块作用域)</strong>：代码块内，比如循环语句内变量；</li><li><strong>类作用域</strong></li><li><strong>命名空间作用域</strong></li></ul><p>类作用域有三种访问方式：</p><ul><li>该类内的成员函数可以直接访问</li><li>在类外，通过<code>类.成员</code>或<code>类::成员</code>访问</li><li>在类外，通过<code>类指针名->成员</code>访问</li></ul><p>具有命名空间作用域的变量称为<strong>全局变量</strong>。命名空间作用域有两种访问方式：</p><ul><li><code>命名空间名::成员;</code></li><li><code>using 命名空间名::成员;</code></li><li><code>using namespace 命名空间名;</code></li></ul><p>作用域的隐藏规则如下：</p><ul><li><p>标识符声明在前，引用在后；</p></li><li><p>同一作用域中，不能声明同名标识符；</p></li><li><p>不同作用域中，可以声明同名标识符；</p></li><li><p>在具有包含关系的两个作用域中，外层声明的标识符：</p><ul><li>如果没有在内层重新声明，外层标识符依然在内层可见；</li><li>如果在内层重新声明，则内层标识符隐藏外层同名标识符，这种机制称为<strong>隐藏规则</strong>。</li></ul></li></ul><h2 id=类和对象进阶>类和对象进阶<a hidden class=anchor aria-hidden=true href=#类和对象进阶>#</a></h2><h4 id=1-构造函数>1. 构造函数<a hidden class=anchor aria-hidden=true href=#1-构造函数>#</a></h4><p>基本数据类型的变量初始化：</p><ul><li>全局变量：声明时没有初始化，则系统自动为其初始化为 <code>0</code>；</li><li>局部变量：声明时没有初始化，则是一个<strong>随机值</strong>。</li></ul><h5 id=构造函数的作用>构造函数的作用<a hidden class=anchor aria-hidden=true href=#构造函数的作用>#</a></h5><p>对象的初始化，需要通过<strong>构造函数</strong>机制，来为对象成员变量赋初值。构造函数是类中的特殊成员函数，给出类定义时，<strong>需要编写构造函数</strong>，如果没有，则<strong>默认由系统添加一个不带参数的构造函数</strong>。</p><p>声明对象后，使用 <code>new</code> 运算符为对象进行初始化，此时<strong>系统自动调用</strong>构造函数，完成对象的初始化工作，保证对象的初始状态是确定的。</p><h5 id=构造函数的定义>构造函数的定义<a hidden class=anchor aria-hidden=true href=#构造函数的定义>#</a></h5><p>定义一个类时，需要为类定义相应的构造函数。构造函数的<strong>函数名与类名相同，没有返回值</strong>。</p><p>一个类的构造函数可以有多个，<strong>允许重载，参数表一定不能完全相同</strong>。</p><p>当类中没有定义任何构造函数时，系统会自动添加一个参数表和函数体都为空的<strong>默认构造函数</strong>。因此，任何类都保证<strong>至少有一个构造函数</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>myDate</span> {};

<span style=color:#75715e>// 定义构造函数 方式一 无参数
</span><span style=color:#75715e></span>myDate<span style=color:#f92672>::</span>myDate() {
    year <span style=color:#f92672>=</span> <span style=color:#ae81ff>1970</span>; month <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; day <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
}

<span style=color:#75715e>// 方式二 有参数 函数体内赋值
</span><span style=color:#75715e></span>myDate<span style=color:#f92672>::</span>myDate(<span style=color:#66d9ef>int</span> y, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> d) {
    year <span style=color:#f92672>=</span> y; month <span style=color:#f92672>=</span> m; day <span style=color:#f92672>=</span> d;
}

<span style=color:#75715e>// 方式三 另一种写法
</span><span style=color:#75715e></span>myDate<span style=color:#f92672>::</span>myDate()<span style=color:#f92672>:</span> year(<span style=color:#ae81ff>1970</span>), month(<span style=color:#ae81ff>1</span>), day(<span style=color:#ae81ff>1</span>) {}  <span style=color:#75715e>// 赋初始值
</span><span style=color:#75715e></span>myDate<span style=color:#f92672>::</span>myDate(<span style=color:#66d9ef>int</span> y, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> d)<span style=color:#f92672>:</span> year(y), month(m), day(d) {}  <span style=color:#75715e>// 从参数列表取值
</span></code></pre></div><h5 id=构造函数的使用>构造函数的使用<a hidden class=anchor aria-hidden=true href=#构造函数的使用>#</a></h5><p>创建类的任何对象时都一定会调用<strong>构造函数</strong>进行初始化。如果程序中声明了对象数组，那么数组的每个元素都是一个对象，<strong>每个元素都要调用</strong>构造函数进行初始化。如果通过类仅声明了指针，并未与对象相关，则不会调用构造函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Test 是类
</span><span style=color:#75715e>// 调用 4 次构造函数，声明指针不会调用
</span><span style=color:#75715e></span>Test <span style=color:#a6e22e>a</span>(<span style=color:#ae81ff>4</span>), b[<span style=color:#ae81ff>3</span>], <span style=color:#f92672>*</span>p;
</code></pre></div><h5 id=复制构造函数>复制构造函数<a hidden class=anchor aria-hidden=true href=#复制构造函数>#</a></h5><p><strong>复制构造函数</strong>是构造函数的一种，也称为<strong>拷贝构造函数</strong>。作用是使用一个已存在的对象去初始化另一个正在创建的对象。</p><p>例如：类对象间的赋值是由复制构造函数实现的。</p><p>复制构造函数<strong>只有一个参数</strong>，参数类型是<strong>本类的引用</strong>。一个类中可以写两个复制构造函数，函数的参数分别为 <code>const</code> 引用和非 <code>const</code> 引用。</p><p>以下三种情况会自动调用复制构造函数：</p><ul><li>用一个对象去初始化另一个对象</li><li>作为函数形参的对象</li><li>作为函数返回值的对象</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>{
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>int</span> x;
        A(<span style=color:#66d9ef>int</span> t) {x <span style=color:#f92672>=</span> t;}  <span style=color:#75715e>// 有参构造函数
</span><span style=color:#75715e></span>        A(A <span style=color:#f92672>&amp;</span>t) {x <span style=color:#f92672>=</span> t.x;}  <span style=color:#75715e>// 复制构造函数一
</span><span style=color:#75715e></span>        A(<span style=color:#66d9ef>const</span> A <span style=color:#f92672>&amp;</span>t) {x <span style=color:#f92672>=</span> t.x;};  <span style=color:#75715e>// 复制构造函数二
</span><span style=color:#75715e></span>};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    A a(<span style=color:#ae81ff>10</span>);
    cout<span style=color:#f92672>&lt;&lt;</span>a.x<span style=color:#f92672>&lt;&lt;</span>endl;  <span style=color:#75715e>// 10
</span><span style=color:#75715e></span>    A b(a);
    cout<span style=color:#f92672>&lt;&lt;</span>b.x<span style=color:#f92672>&lt;&lt;</span>endl;  <span style=color:#75715e>// 10
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h4 id=2-析构函数>2. 析构函数<a hidden class=anchor aria-hidden=true href=#2-析构函数>#</a></h4><p>析构函数也是成员函数的一种，名字与类名相同，但要在类名前加一个 <code>~</code> 符号，以区别构造函数。</p><p>析构函数<strong>没有参数，也没有返回值</strong>。一个类中<strong>有且仅有一个</strong>析构函数。如果未定义，则系统自动生成函数体为空的默认析构函数。</p><p>析构函数的作用是做一些善后处理的工作，当对象消亡时<strong>自动调用</strong>析构函数。比如通过 <code>new</code> 创建的对象，使用 <code>delete</code> 释放空间时，首先调用对象的析构函数，然后再释放对象占用的空间。</p><p>对于对象数组，要为它的每个元素调用一个构造函数和析构函数。析构函数的调用执行顺序与构造函数<strong>正好相反</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> {
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
        Test();
        <span style=color:#f92672>~</span>Test();
    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p;
};

Test<span style=color:#f92672>::</span>Test() {
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Test 构造函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
    p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>10</span>];  <span style=color:#75715e>// 指针指向堆空间
</span><span style=color:#75715e></span>}

Test<span style=color:#f92672>::~</span>Test() {
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Test 析构函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
    <span style=color:#66d9ef>delete</span> p;  <span style=color:#75715e>// 必须显式的声明析构函数，释放空间，避免内存泄漏
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Test t;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h4 id=3-变量及对象的生存期和作用域>3. 变量及对象的生存期和作用域<a hidden class=anchor aria-hidden=true href=#3-变量及对象的生存期和作用域>#</a></h4><p><strong>全局变量</strong></p><ul><li>未赋初值默认为 <code>0</code>，字符型变量为空字符</li><li>作用域：定义在函数外，可被所有文件的函数使用，其他文件使用需 <code>extern</code> 声明（外部链接）</li><li>生存期：整个程序执行期</li><li>不同文件的全局变量不可以重名</li></ul><p><strong>局部变量</strong></p><ul><li>未赋初值，内容为随机</li><li>作用域：程序块内</li><li>生存期：程序块执行期</li><li>同一文件中全局变量和局部变量可以重名，在局部变量作用域内，全局变量不起作用</li></ul><p><strong>静态全局变量</strong></p><ul><li>值只初始化一次，未赋初值默认为 <code>0</code>，字符型变量为空字符</li><li>作用域：本文件内，存储在全局数据区</li><li>生存期：整个程序执行期</li><li>不同文件的静态全局变量可以重名</li></ul><p><strong>静态局部变量</strong></p><ul><li>值只初始化一次，未赋初值默认为 <code>0</code>，字符型变量为空字符</li><li>作用域：程序块内，存储在全局数据区</li><li>生存期：整个程序执行期</li></ul><p>使用 <code>new</code> 创建的变量具有动态生存期，从声明处开始，直到用 <code>delete</code> 释放存储空间或程序结束。</p><p><strong>类对象的生存期</strong>为调用构造函数开始到消亡时调用析构函数。</p><h4 id=4-类的静态成员>4. 类的静态成员<a hidden class=anchor aria-hidden=true href=#4-类的静态成员>#</a></h4><p>类的静态成员分为：</p><ul><li>静态成员变量</li><li>静态成员函数</li></ul><p>类的静态成员只有一份保存在公用内存中，被类的所有对象<strong>共享</strong>。静态成员定义时，需要在前面添加 <code>static</code> 关键字。必须在<strong>类体外</strong>赋静态成员变量的初值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Book</span> {
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> page_num;  <span style=color:#75715e>// 静态数据成员
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() {  <span style=color:#75715e>// 静态函数才能调用静态变量
</span><span style=color:#75715e></span>            cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;已阅读到的页码为：&#34;</span><span style=color:#f92672>&lt;&lt;</span>page_num<span style=color:#f92672>&lt;&lt;</span>endl;
        }
};

<span style=color:#66d9ef>int</span> Book<span style=color:#f92672>::</span>page_num <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;  <span style=color:#75715e>// 静态数据成员的初值只能在类体外定义，不需要加 static 关键字
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Book b1, b2, <span style=color:#f92672>*</span>b3;

    b1.print();  <span style=color:#75715e>// 100
</span><span style=color:#75715e></span>    b2.print();  <span style=color:#75715e>// 100 该类的所有对象公用一个静态数据成员
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// 静态成员访问的三种方法
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>Book<span style=color:#f92672>::</span>page_num<span style=color:#f92672>&lt;&lt;</span>endl;  <span style=color:#75715e>// 类名.静态成员名
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>b1.page_num<span style=color:#f92672>&lt;&lt;</span>endl;     <span style=color:#75715e>// 对象.静态成员名
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>b3<span style=color:#f92672>-&gt;</span>page_num<span style=color:#f92672>&lt;&lt;</span>endl;    <span style=color:#75715e>// 对象指针-&gt;静态成员名
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p><strong>类的静态函数只能处理类的静态成员变量</strong>。静态函数与静态函数之间、非静态函数与非静态函数之间是可以相互调用的，非静态成员函数内可以调用静态成员函数，但静态成员函数内不能调用非静态成员函数。</p><h4 id=5-常量成员和常引用成员>5. 常量成员和常引用成员<a hidden class=anchor aria-hidden=true href=#5-常量成员和常引用成员>#</a></h4><p>在类中，可以使用关键字 <code>const</code> 定义成员变量、成员函数、类的对象。</p><p>类的常量成员变量必须进行初始化，且只能通过构造函数的成员初始化列表的方式进行。</p><p>定义常量成员变量或常量对象：<code>const 数据类型 常量名 = 表达式;</code></p><p>定义常量函数：<code>类型说明符 函数名(参数表) const;</code></p><p>对象被创建以后，常量成员变量的<strong>值不允许被修改</strong>，只可以读其值。对于常量对象，<strong>只能调用常量函数</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>void</span> test() {}  <span style=color:#75715e>// 非常量成员函数
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>demo</span>() <span style=color:#66d9ef>const</span> {}  <span style=color:#75715e>// 常量成员函数
</span><span style=color:#75715e></span>};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>const</span> A a;
    a.test();  <span style=color:#75715e>// 错误 常量对象不能调用非常量成员函数
</span><span style=color:#75715e></span>    a.demo();  <span style=color:#75715e>// 正确
</span><span style=color:#75715e></span>}
</code></pre></div><h4 id=6-成员对象和封闭类>6. 成员对象和封闭类<a hidden class=anchor aria-hidden=true href=#6-成员对象和封闭类>#</a></h4><p>一个类的成员变量如果是另一个类的对象，则该成员变量称为<strong>成员对象</strong>。这两个类为包含关系，包含成员对象的类叫做<strong>封闭类</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Tyres</span> {
    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>int</span> radius, width;
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
        Tyres(<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> w)<span style=color:#f92672>:</span> radius(r), width(w) {
            cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Tyres(radius=&#34;</span><span style=color:#f92672>&lt;&lt;</span>radius<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;, width=&#34;</span><span style=color:#f92672>&lt;&lt;</span>width<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;)&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
        };
};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Car</span> {
    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>int</span> prices;
        Tyres tyres;
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
        Car(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> tr, <span style=color:#66d9ef>int</span> td);
};

<span style=color:#75715e>// 定义封闭类构造函数中，需要指明调用成员对象的哪个构造函数 如：Tyres(int, int)
</span><span style=color:#75715e></span>Car<span style=color:#f92672>::</span>Car(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> tr, <span style=color:#66d9ef>int</span> td)<span style=color:#f92672>:</span> prices(p), tyres(tr, td) {
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Gogogo!&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;  <span style=color:#75715e>// 先调用成员对象的构造函数，在调用封闭类对象的构造函数
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Car car(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>6</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#75715e>// Tyres(radius=3, width=6)
</span><span style=color:#75715e>// Gogogo!
</span></code></pre></div><h4 id=7-友元函数>7. 友元函数<a hidden class=anchor aria-hidden=true href=#7-友元函数>#</a></h4><p>设置私有成员的机制叫做<strong>隐藏</strong>。修改私有属性需要通过公有函数，函数内可以避免对对象的不正确操作或做一些其他修改。私有类型的成员在类外不能访问，通过类内公有函数可以访问但是比直接访问的效率低，所以提供了友元访问方式。</p><p>友元函数内部可以<strong>直接访问本类对象的私有成员</strong>，友元函数不是类的成员函数，但允许访问类中的所有成员。不受类中的访问权限关键字限制，可以把它放在类的公有、私有、保护部分，结果是一样的。友元的概念破坏了类的封装性和信息隐藏，但有助于数据共享，能够提高程序执行的效率。</p><p>友元函数使用关键字 <code>friend</code> 标识，定义方式 ：</p><ul><li><p><code>friend 返回值类型 函数名(参数表);</code></p></li><li><p><code>friend 返回值类型 类名::函数名(参数表);</code></p></li></ul><p>一个函数可以声明为多个类的友元函数，一个类中也可以有多个友元函数。</p><h5 id=友元类>友元类<a hidden class=anchor aria-hidden=true href=#友元类>#</a></h5><p>如果将一个类 B 说明为类 A 的友元类，则类 B 中的所有函数都是类 A 的友元函数，在类 B 的所有成员函数中都可以访问类 A 中的所有成员。</p><p>声明格式为：<code>friend class 类名;</code></p><p>友元类的关系是<strong>单向</strong>的，友元类的关系<strong>不能传递</strong>。一般不把整个类说明为友元类。</p><h4 id=8-this-指针>8. this 指针<a hidden class=anchor aria-hidden=true href=#8-this-指针>#</a></h4><p>当调用一个成员函数时，系统自动向它传递一个隐含的参数，该参数是一个指向<strong>调用该函数的对象</strong>的指针，称为 <code>this</code> 指针，从而使成员函数知道对哪个对象进行操作。</p><ul><li><p>非静态成员函数内部可以直接使用 <code>this</code> 关键字，代表指向该函数所作用的对象的指针</p></li><li><p>静态成员函数<strong>没有</strong> <code>this</code> 指针</p></li><li><p>一般情况下，可以省略 <code>this-></code>，系统采用默认设置</p></li></ul><h2 id=运算符重载>运算符重载<a hidden class=anchor aria-hidden=true href=#运算符重载>#</a></h2><h4 id=运算符重载的概念>运算符重载的概念<a hidden class=anchor aria-hidden=true href=#运算符重载的概念>#</a></h4><p>算术运算符包括：<code>+ - * / %</code>，通常只能用于对基本数据类型的常量或变量进行运算，而不能用于对象之间的运算。运算符重载可以使运算符也能用来<strong>操作对象</strong>。</p><p><img src="/Users/lan/Library/Application Support/typora-user-images/image-20221012105520576.png" alt=可重载的运算符 style=zoom:50%><img src="/Users/lan/Library/Application Support/typora-user-images/image-20221012105617026.png" alt=不可重载的运算符 style=zoom:50%></p><p>重载运算符有一个返回类型和一个参数列表，这样的函数称为<strong>运算符函数</strong>。运算符可以被重载为<strong>全局函数</strong>，也可以被重载为类的成员函数。声明为全局函数时，通常应是类的友元。运算符函数是一种<strong>特殊的友元函数或成员函数</strong>。</p><h5 id=重载运算符的规则>重载运算符的规则<a hidden class=anchor aria-hidden=true href=#重载运算符的规则>#</a></h5><ul><li>符合原有的用法习惯</li><li>不能改变运算符原有的语义</li><li>不能改变运算符操作数的个数及语法结构</li><li>不能创建新的运算符</li><li>重载运算符<code>() [] -> =</code> 时，只能重载为成员函数，不能为全局函数</li><li>不能改变运算符用于基本数据类型对象的含义</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>myComplex <span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(<span style=color:#66d9ef>const</span> myComplex <span style=color:#f92672>&amp;</span> c1, <span style=color:#66d9ef>const</span> myComplex <span style=color:#f92672>&amp;</span> c2) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>myComplex</span>(c1.real <span style=color:#f92672>+</span> c2.real, c1.imag <span style=color:#f92672>+</span> c2.imag); 
}
myComplex <span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(<span style=color:#66d9ef>const</span> myComplex<span style=color:#f92672>&amp;</span> c1, <span style=color:#66d9ef>double</span> r) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>myComplex</span>(c1.real <span style=color:#f92672>+</span> r, c1.imag); 
}
myComplex <span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(<span style=color:#66d9ef>double</span> r, <span style=color:#66d9ef>const</span> myComplex<span style=color:#f92672>&amp;</span> c1) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>myComplex</span>(r <span style=color:#f92672>+</span> c1.real, c1.imag); 
}

myComplex <span style=color:#66d9ef>operator</span><span style=color:#f92672>-</span>(<span style=color:#66d9ef>const</span> myComplex<span style=color:#f92672>&amp;</span> c1, <span style=color:#66d9ef>const</span> myComplex<span style=color:#f92672>&amp;</span> c2) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>myComplex</span>(c1.real <span style=color:#f92672>-</span> c2.real, c1.imag <span style=color:#f92672>-</span> c2.imag); 
}
myComplex <span style=color:#66d9ef>operator</span><span style=color:#f92672>-</span>(<span style=color:#66d9ef>const</span> myComplex<span style=color:#f92672>&amp;</span> c1, <span style=color:#66d9ef>double</span> r) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>myComplex</span>(c1.real <span style=color:#f92672>-</span> r, c1.imag); 
}
myComplex <span style=color:#66d9ef>operator</span><span style=color:#f92672>-</span>(<span style=color:#66d9ef>double</span> r, <span style=color:#66d9ef>const</span> myComplex<span style=color:#f92672>&amp;</span> c1) {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>myComplex</span>(r <span style=color:#f92672>-</span> c1.real, <span style=color:#f92672>-</span>c1.imag); 
}
</code></pre></div><h5 id=重载赋值运算符>重载赋值运算符<a hidden class=anchor aria-hidden=true href=#重载赋值运算符>#</a></h5><p>赋值运算符 <code>=</code> 只能重载为成员函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>myComplex<span style=color:#f92672>&amp;</span> myComplex<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> myComplex<span style=color:#f92672>&amp;</span> c1) {
	<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>real <span style=color:#f92672>=</span> c1.real; 
    <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>imag <span style=color:#f92672>=</span> c1.imag; 
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
}
myComplex<span style=color:#f92672>&amp;</span> myComplex<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>double</span> r) {
	<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>real <span style=color:#f92672>=</span> r; 
    <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>imag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; 
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
}
</code></pre></div><p>同类对象之间可以通过赋值运算符进行赋值。如果没有经过重载，<code>=</code> 的作用就是将赋值号右侧对象的值一一赋值给左侧的对象。这相当于值的拷贝，称为<strong>浅拷贝</strong>。重载赋值运算符后，赋值语句的功能是将一个对象中指针成员变量指向的内容复制到另一个对象指针成员变量指向的地方，这样的拷贝叫<strong>深拷贝</strong>。</p><h5 id=重载流插入运算符和流提取运算符>重载流插入运算符和流提取运算符<a hidden class=anchor aria-hidden=true href=#重载流插入运算符和流提取运算符>#</a></h5><ul><li>流插入运算符(cout) <code>&lt;&lt;</code></li><li>流提取运算符(cin) <code>>></code></li></ul><p>只能采用友元函数重载的方式。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream.h&gt; </span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span>
{
	<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
		<span style=color:#66d9ef>int</span> i; <span style=color:#66d9ef>float</span> f; <span style=color:#66d9ef>char</span> ch;
	<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
		test(<span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>float</span> b<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>char</span> c<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;\0&#39;</span>) {i<span style=color:#f92672>=</span>a; f<span style=color:#f92672>=</span>b; ch<span style=color:#f92672>=</span>c;} 
    	<span style=color:#66d9ef>friend</span> ostream <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(ostream <span style=color:#f92672>&amp;</span>, test);    <span style=color:#75715e>// 必须重载为类的友元
</span><span style=color:#75715e></span>    	<span style=color:#66d9ef>friend</span> istream <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&gt;&gt;</span>(istream <span style=color:#f92672>&amp;</span>, test <span style=color:#f92672>&amp;</span>);  <span style=color:#75715e>// 必须重载为类的友元
</span><span style=color:#75715e></span>};

ostream <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(ostream <span style=color:#f92672>&amp;</span>stream, test obj)
{
	stream<span style=color:#f92672>&lt;&lt;</span>obj.i<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;,&#34;</span>;  <span style=color:#75715e>// stream 是 cout 的别名  
</span><span style=color:#75715e></span>    stream<span style=color:#f92672>&lt;&lt;</span>obj.f<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;,&#34;</span>;
    stream<span style=color:#f92672>&lt;&lt;</span>obj.ch<span style=color:#f92672>&lt;&lt;</span>endl;
	<span style=color:#66d9ef>return</span> stream;
}

istream <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&gt;&gt;</span>(istream <span style=color:#f92672>&amp;</span>t_stream, test <span style=color:#f92672>&amp;</span>obj)
{
	t_stream<span style=color:#f92672>&gt;&gt;</span>obj.i;  <span style=color:#75715e>// t_stream 是 cin 的别名 
</span><span style=color:#75715e></span>    t_stream<span style=color:#f92672>&gt;&gt;</span>obj.f;
	t_stream<span style=color:#f92672>&gt;&gt;</span>obj.ch;
	<span style=color:#66d9ef>return</span> t_stream;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() {
    test A;
    <span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(cout, <span style=color:#e6db74>&#34;Input as i f ch:&#34;</span>);
    <span style=color:#66d9ef>operator</span><span style=color:#f92672>&gt;&gt;</span>(cin, A);  <span style=color:#75715e>// 45,8.5,&#39;W’
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(cout,A);  <span style=color:#75715e>// 45,8.5,&#39;W’
</span><span style=color:#75715e></span>    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h5 id=重载自增自减运算符>重载自增、自减运算符<a hidden class=anchor aria-hidden=true href=#重载自增自减运算符>#</a></h5><ul><li><p>自增运算符：<code>++k</code> <code>k++</code></p></li><li><p>自减运算符：<code>--k</code> <code>k--</code></p></li></ul><p>按照定义，<code>++k</code> 返回被修改后的值，<code>k++</code> 返回被修改前的值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e># include &lt;iostream&gt;
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Demo</span> {
    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>int</span> n;
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
        Demo(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)<span style=color:#f92672>:</span> n(i) {}
        <span style=color:#66d9ef>operator</span> <span style=color:#a6e22e>int</span>() {<span style=color:#66d9ef>return</span> n;}
        Demo <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>();   <span style=color:#75715e>// 用于前置形式
</span><span style=color:#75715e></span>        Demo <span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>(<span style=color:#66d9ef>int</span>);  <span style=color:#75715e>// 用于后置形式
</span><span style=color:#75715e></span>};

Demo <span style=color:#f92672>&amp;</span>Demo<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>() {
    n<span style=color:#f92672>++</span>;
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
}

Demo Demo<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>(<span style=color:#66d9ef>int</span> k) {
    Demo <span style=color:#a6e22e>tmp</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);  <span style=color:#75715e>// 记录修改前的对象
</span><span style=color:#75715e></span>    n<span style=color:#f92672>++</span>;
    <span style=color:#66d9ef>return</span> tmp;  <span style=color:#75715e>// 返回修改前的对象
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Demo d(<span style=color:#ae81ff>10</span>);
    <span style=color:#75715e>// 后置形式两种写法
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>(d<span style=color:#f92672>++</span>)<span style=color:#f92672>&lt;&lt;</span>endl;  <span style=color:#75715e>// 10
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>d<span style=color:#f92672>&lt;&lt;</span>endl;      <span style=color:#75715e>// 11
</span><span style=color:#75715e></span>    d.<span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>(<span style=color:#ae81ff>0</span>);    <span style=color:#75715e>// 11 不输出 有参代表后置形式
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>d<span style=color:#f92672>&lt;&lt;</span>endl;      <span style=color:#75715e>// 12
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// 前置形式两种写法     
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>(<span style=color:#f92672>++</span>d)<span style=color:#f92672>&lt;&lt;</span>endl;   <span style=color:#75715e>// 13 
</span><span style=color:#75715e></span>    d.<span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>();      <span style=color:#75715e>// 14 不输出 无参代表前置形式
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>d<span style=color:#f92672>&lt;&lt;</span>endl;       <span style=color:#75715e>// 14
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h2 id=类的继承与派生>类的继承与派生<a hidden class=anchor aria-hidden=true href=#类的继承与派生>#</a></h2><p>通过已有的类建立新类的过程，叫做类的派生。</p><ul><li>原来的类称为<strong>基类、父类、一般类</strong>；</li><li>新类称为<strong>派生类、子类、特殊类</strong>。</li></ul><p>派生类继承于基类，基类派生了派生类，派生类可以作为基类再次派生新的派生类，这种集合称作类继承层次结构。</p><p>使用基类派生新类时，<strong>除构造函数和析构函数</strong>外，基类的所有成员<strong>自动</strong>成为派生类的成员，包括基类的成员变量和成员函数。派生类中需要定义自己的构造函数和析构函数，可以<strong>增加</strong>基类中没有的成员，还可以重新定义或<strong>修改</strong>基类中已有的成员，包括可以改变基类中成员的访问权限。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 基类与派生类的定义
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
    <span style=color:#66d9ef>int</span> a, b;
};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
    <span style=color:#66d9ef>int</span> c;
};
</code></pre></div><p>派生类占用的存储空间大小，等于<strong>基类成员变量</strong>占用存储空间大小 <strong>加上</strong> <strong>派生类对象自身成员变量</strong>占用的存储空间大小。对象占用的存储空间包含对象中各成员变量占用的存储空间。可以使用 <code>sizeof()</code> 计算对象占用的字节数。</p><p>基类有友元，派生类<strong>不会继承友元类或友元函数</strong>。如果基类是某类的友元，那么这种友元关系是继承的。如果基类中的成员是静态的，在派生类中静态属性随静态成员被继承。如果基类的静态成员是公有的或者保护的，则他们被其派生类继承为派生类的静态成员。</p><p>C++ 允许从多个类派生一个类，即一个派生类可以同时有多个基类。这称为<strong>多重继承</strong>。相应地，从一个基类派生一个派生类的情况，称为单继承或单重继承。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C1</span> {};
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C2</span> {};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C3</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> C1, <span style=color:#66d9ef>public</span> C2 {
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;多重继承&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
};
</code></pre></div><ul><li>如果派生类中新增了同名成员，则派生类成员将隐藏所有基类的同名成员，使用<strong>派生类对象名.成员名</strong> 或 <strong>派生类对象指针->成员名</strong> 的方式可以唯一标识和访问派生类的新增成员。这种情况下，不会产生二义性。</li><li>如果派生类中没有新增同名成员，使用上面的方式访问成员时，系统无法判断到底调用哪个基类的成员，产生二义性，为避免这种情况，必须通过 <strong>基类名和作用域分辨符</strong> 来标识成员。当访问派生类对象中某个变量时，添加 <strong>基类::</strong> 作为前缀，指明访问从哪个基类集成来的成员。</li></ul><h4 id=访问控制>访问控制<a hidden class=anchor aria-hidden=true href=#访问控制>#</a></h4><ul><li>public：共有继承</li><li>private：私有继承</li><li>protected：保护继承</li></ul><p>类的共有继承</p><table><thead><tr><th>各成员</th><th>派生类中</th><th>基类与派生类外</th></tr></thead><tbody><tr><td>基类的公有成员</td><td>直接访问</td><td>直接访问</td></tr><tr><td>基类的保护成员</td><td>直接访问</td><td>调用公有函数访问</td></tr><tr><td>基类的私有成员</td><td>调用公有函数访问</td><td>调用公有函数访问</td></tr><tr><td>从基类继承的公有成员</td><td>直接访问</td><td>直接访问</td></tr><tr><td>从基类继承的保护成员</td><td>直接访问</td><td>调用公有函数访问</td></tr><tr><td>从基类继承的私有成员</td><td>调用公有函数访问</td><td>调用公有函数访问</td></tr><tr><td>派生类中定义的公有成员</td><td>直接访问</td><td>直接访问</td></tr><tr><td>派生类中定义的保护成员</td><td>直接访问</td><td>调用公有函数访问</td></tr><tr><td>派生类中定义的私有成员</td><td>直接访问</td><td>调用公有函数访问</td></tr></tbody></table><p>类的私有继承</p><table><thead><tr><th></th><th>第一级派生类中</th><th>第二级派生类中</th><th>基类与派生类外</th></tr></thead><tbody><tr><td>基类的共有成员</td><td>直接访问</td><td>不可访问</td><td>不可访问</td></tr><tr><td>基类的保护成员</td><td>直接访问</td><td>不可访问</td><td>不可访问</td></tr><tr><td>基类的私有成员</td><td>通过公有函数访问</td><td>不可访问</td><td>不可访问</td></tr></tbody></table><h4 id=类型兼容规则>类型兼容规则<a hidden class=anchor aria-hidden=true href=#类型兼容规则>#</a></h4><p>在公有派生的情况下，有以下<strong>三条兼容规则</strong>：</p><ul><li>派生类的对象可以赋值给基类对象；</li><li>派生类的对象可以用来初始化基类引用；</li><li>派生类对象的地址可以赋值给基类指针，即派生类的指针可以赋值给基类的指针。</li></ul><h5 id=派生类的构造函数与析构函数>派生类的构造函数与析构函数<a hidden class=anchor aria-hidden=true href=#派生类的构造函数与析构函数>#</a></h5><p>在执行一个派生类构造函数之前，总是先执行基类的构造函数。派生类对象消亡是时，先执行派生类的析构函数，在执行基类的析构函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt; </span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#75715e>//基类
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BaseClass</span> {  
<span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
	<span style=color:#66d9ef>int</span> v1,v2; 
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
	BaseClass(); 
    BaseClass(<span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span>); 
    <span style=color:#f92672>~</span>BaseClass();
};

BaseClass<span style=color:#f92672>::</span>BaseClass() { 
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;BaseClass 无参构造函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
} 
BaseClass<span style=color:#f92672>::</span>BaseClass(<span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n) { 
    v1<span style=color:#f92672>=</span>m; v2<span style=color:#f92672>=</span>n;
	cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;BaseClass 无参构造函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
} 
BaseClass<span style=color:#f92672>::~</span>BaseClass() { 
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;BaseClass 析构函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl; 
}

<span style=color:#75715e>// 派生类
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DerivedClass</span><span style=color:#f92672>:</span><span style=color:#66d9ef>public</span> BaseClass {
<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> v3;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
	DerivedClass(); 
    DerivedClass(<span style=color:#66d9ef>int</span>); 
    DerivedClass(<span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span>); 
    <span style=color:#f92672>~</span>DerivedClass();
};

DerivedClass<span style=color:#f92672>::</span>DerivedClass() {
	cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;DerivedClass 无参构造函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
}
DerivedClass<span style=color:#f92672>::</span>DerivedClass(<span style=color:#66d9ef>int</span> k)<span style=color:#f92672>:</span>v3(k) {
	cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;DerivedClass 带1个参数构造函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
}
DerivedClass<span style=color:#f92672>::</span>DerivedClass(<span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> k)<span style=color:#f92672>:</span>BaseClass(m, n), v3(k) {
	cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;DerivedClass 带3个参数构造函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl; 
}
DerivedClass<span style=color:#f92672>::~</span>DerivedClass() {
	cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;DerivedClass 析构函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl; 
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;无参对象的创建&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
    BaseClass b;
    DerivedClass d;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#75715e>/* 输出内容：
</span><span style=color:#75715e>无参对象的创建
</span><span style=color:#75715e>BaseClass 无参构造函数
</span><span style=color:#75715e>BaseClass 无参构造函数
</span><span style=color:#75715e>DerivedClass 无参构造函数
</span><span style=color:#75715e>DerivedClass 析构函数
</span><span style=color:#75715e>BaseClass 析构函数
</span><span style=color:#75715e>BaseClass 析构函数
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>派生类构造函数执行顺序一般次序如下：</p><ul><li>调用基类构造函数，<strong>调用顺序按照它们被继承时声明的顺序</strong>（从左向右）</li><li>对派生类新增的成员变量初始化，<strong>调用顺序按照它们在类中声明的顺序</strong></li><li>执行派生类的构造函数体重的内容</li></ul><p>在派生类构造函数执行之前，要先执行两个基类的构造函数，执行次序依据定义派生类时所列基类的次序而定。</p><h5 id=类之间的关系>类之间的关系<a hidden class=anchor aria-hidden=true href=#类之间的关系>#</a></h5><p>使用已有类编写新的类有两种方式：</p><ul><li><strong>继承关系</strong>：也称为 <strong>is a</strong> 关系或 <strong>是</strong> 关系</li><li><strong>组合关系</strong>：也称为 <strong>has a</strong> 关系或 <strong>有</strong> 关系，表现为封闭类</li></ul><p>封闭类：如果一个类的成员变量是另一个类的对象，则为封闭类。</p><p>如果基类为封闭类，函数调用顺序如下：</p><ul><li>构造函数：对象成员构造函数 - 基类构造函数 - 派生类构造函数</li><li>析构函数：派生类析构函数 - 基类析构函数 - 对象成员析构函数</li></ul><p>互包含关系的类，两个类相互引用，这种情况称为循环依赖。</p><h5 id=多层次的派生>多层次的派生<a hidden class=anchor aria-hidden=true href=#多层次的派生>#</a></h5><ul><li>派生类沿着类的层次自动向上继承它所有的直接和间接基类的成员，类之间的继承关系具有<strong>传递性</strong></li><li>派生类的成员包括派生类自己定义的成员、直接基类中定义的成员及所有间接基类中定义的全部成员</li><li>当生成派生类的对象时，会从最顶层的<strong>基类开始逐层往下</strong>执行所有基类的<strong>构造函数</strong>，最后执行派生类自身的构造函数；当派生类对象消亡时，会先执行自身的析构函数，然后<strong>自底向上</strong>依次执行各个基类的<strong>析构</strong>函数</li></ul><p>一个类不能被多次说明为某个派生类的直接基类，可以不止一次地称为间接基类。</p><h5 id=基类与派生类指针的相互转换>基类与派生类指针的相互转换<a hidden class=anchor aria-hidden=true href=#基类与派生类指针的相互转换>#</a></h5><p>在公有派生的情况下，因为派生类对象也是基类对象，所以派生类对象可以赋给基类对象。</p><p>对于指针类型，<strong>可以使用基类指针指向派生类对象</strong>，也可以<strong>将派生类的指针直接赋值给基类指针</strong>。但即使基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类中没有而仅在派生类中定义的成员函数。</p><h2 id=多态与虚函数>多态与虚函数<a hidden class=anchor aria-hidden=true href=#多态与虚函数>#</a></h2><h3 id=多态的基本概念>多态的基本概念<a hidden class=anchor aria-hidden=true href=#多态的基本概念>#</a></h3><h4 id=多态>多态<a hidden class=anchor aria-hidden=true href=#多态>#</a></h4><p>多态分为：</p><ul><li><strong>编译时多态</strong>：<strong>函数的重载</strong>（包括运算符重载）。编译时根据实参确定应该调用哪个函数，<strong>编译阶段</strong>的多态称为<strong>静态多态</strong>，一个对象调用同名函数；</li><li><strong>运行时多态</strong>：和继承、虚函数等概念有关，主要指运行时多态，<strong>运行阶段</strong>的多态称为<strong>动态多态</strong>，不同对象调用同名函数。</li></ul><p>在类直接满足 <strong>赋值兼容的前提下</strong>，实现动态绑定必须满足两个条件：</p><ul><li>必须<strong>声明虚函数</strong></li><li>通过<strong>基类类型的引用或指针</strong>调用虚函数</li></ul><p>多态实现原理：多态的关键在于通过基类指针或引用调用一个虚函数时，编译阶段不能确定到底调用的是基类还是派生类的函数，运行时才能确定。</p><p><strong>派生类对象占用的存储空间大小，等于基类成员变量占用的存储空间大小加上派生类对象自身成员变量占用的存储孔家你大小。</strong></p><h4 id=虚函数>虚函数<a hidden class=anchor aria-hidden=true href=#虚函数>#</a></h4><ul><li>在函数声明前加了 <code>virtual</code> 关键字的成员函数</li><li><strong>只能在类定义中的成员函数声明处使用</strong>，类体外编写函数体时不加该关键字</li><li>不能声明为虚函数的有：<strong>全局函数（非成员函数）、静态成员函数、内联函数、构造函数和友元函数</strong></li><li><strong>不要在构造函数和析构函数中调用虚函数</strong></li><li><strong>最好将基类的析构函数声明为虚函数</strong></li><li>包含虚函数的类称为 <strong>多态类</strong></li><li>派生类重写基类的虚函数实现多态，要求函数名、参数列表和返回值类型要完全相同</li><li>基类中定义了虚函数，在派生类中该函数始终保持虚函数的特性</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base1</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>void</span> show() { cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Base1::show()&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl; }
};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base2</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base1 {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>void</span> show() { cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Base2::show()&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl; }
};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base2 {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>void</span> show() { cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Derived::show()&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl; }
};

<span style=color:#75715e>// 通过基类类型的指针或引用调用
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(Base1 <span style=color:#f92672>*</span>p) {
    p <span style=color:#f92672>-&gt;</span> show();
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#75715e>// b1 是基类，b2 继承自 b1，d 继承自 b2
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 通过子类对象赋值给基类时，调用同名方法都会变成基类的方法
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 没有实现多态
</span><span style=color:#75715e></span>    Base1 b1; Base2 b2; Derived d;
    func(<span style=color:#f92672>&amp;</span>b1); func(<span style=color:#f92672>&amp;</span>b2); func(<span style=color:#f92672>&amp;</span>d);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#75715e>/*
</span><span style=color:#75715e>Base1::show()
</span><span style=color:#75715e>Base1::show()
</span><span style=color:#75715e>Base1::show()
</span><span style=color:#75715e>*/</span>
</code></pre></div><p>通过虚函数实现多态</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base1</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> show() { cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Base1::show()&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl; }
};

<span style=color:#75715e>/*
</span><span style=color:#75715e>只需要修改基类的同名方法为虚函数，派生类中自然继承
</span><span style=color:#75715e>再次执行，输出结果为：实现多态
</span><span style=color:#75715e>Base1::show()
</span><span style=color:#75715e>Base2::show()
</span><span style=color:#75715e>Derived::show()
</span><span style=color:#75715e>*/</span>
</code></pre></div><h4 id=虚析构函数>虚析构函数<a hidden class=anchor aria-hidden=true href=#虚析构函数>#</a></h4><p>如果一个基类指针指向的对象是用 <code>new</code> 运算符动态生成的派生类对象，那么释放该对象所占用的空间时，如果仅调用基类的析构函数，则只会完成该析构函数内的空间释放，不会涉及派生类析构函数内的空间释放，容易造成内存泄漏。</p><p><strong>使用虚析构函数的目的是为了在对象消亡时实现多态</strong>。</p><p>声明虚析构函数格式：<strong>virtual ~类名();</strong></p><ul><li>虚析构函数没有返回值类型，没有参数</li><li>如果一个类的析构函数是虚函数，那么由它派生的所有子类的析构函数都是虚析构函数</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std; 

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    Base() { 
        cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Base::构造函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
    }
    <span style=color:#75715e>// 虚析构函数，子类自动也变为虚析构函数
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>Base() {
        cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Base::析构函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
    } 
};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> w,h; <span style=color:#75715e>//两个成员
</span><span style=color:#75715e></span>    Derived() { 
        cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Derived::构造函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
        w<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>; h<span style=color:#f92672>=</span><span style=color:#ae81ff>7</span>; 
    } 
    <span style=color:#f92672>~</span>Derived() { 
        cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Derived::析构函数&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
    } 
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    Base <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Derived();
    <span style=color:#75715e>//使用基类指针指向new创建的派生类对象 
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>delete</span> p;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#75715e>/*
</span><span style=color:#75715e>输出：
</span><span style=color:#75715e>Base::构造函数
</span><span style=color:#75715e>Derived::构造函数
</span><span style=color:#75715e>Derived::析构函数  // 如果声明虚析构函数的话，就不会调用派生类的析构函数了
</span><span style=color:#75715e>Base::析构函数
</span><span style=color:#75715e>*/</span>
</code></pre></div><h4 id=纯虚函数>纯虚函数<a hidden class=anchor aria-hidden=true href=#纯虚函数>#</a></h4><p>纯虚函数的作用相当于一个统一的接口形式，表明在基类的各派生类中应该有这样的一个操作，然后在各派生类中具体实现与本派生类相关的操作。</p><p>纯虚函数是声明在基类中的虚函数，没有具体定义。</p><p>声明格式：<strong>virtual 函数类型 函数名(参数表) = 0;</strong></p><h4 id=抽象类>抽象类<a hidden class=anchor aria-hidden=true href=#抽象类>#</a></h4><p>包含纯虚函数的类称为抽象类。因为抽象类中含有未完成的函数定义，所以不能实例化一个对象。</p><p>抽象类的派生类中，如果没有给出全部纯虚函数的定义，则该派生类继续是抽象类。</p><p>虽然不能创建抽象类对象，但是<strong>可以定义抽象类的指针和引用</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 假设 Foo 为抽象类
</span><span style=color:#75715e></span>Foo <span style=color:#f92672>*</span>p;
</code></pre></div><h4 id=虚基类>虚基类<a hidden class=anchor aria-hidden=true href=#虚基类>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt; </span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std; 

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span> 
    <span style=color:#66d9ef>int</span> a;
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>showa</span>() { 
        cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;a=&#34;</span><span style=color:#f92672>&lt;&lt;</span>a<span style=color:#f92672>&lt;&lt;</span>endl; 
    } 
};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>public</span> A {  <span style=color:#75715e>// 对类 A 进行了虚继承 
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> b;
}; 

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>public</span> A {  <span style=color:#75715e>//对类 A 进行了虚继承
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>  
    <span style=color:#66d9ef>int</span> c;
};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>D</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> B, <span style=color:#66d9ef>public</span> C {
<span style=color:#75715e>// 派生类 D 的两个基类 B、C 具有共同的基类 A,
</span><span style=color:#75715e>// 采用了虚继承，从而使类 D 的对象中只包含着类 A 的 1 个实例
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span> 
    <span style=color:#66d9ef>int</span> d;
}; 

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    D d;  <span style=color:#75715e>// 说明派生类D的对象
</span><span style=color:#75715e></span>    d.a <span style=color:#f92672>=</span> <span style=color:#ae81ff>11</span>;  <span style=color:#75715e>// 若不是虚继承，此行会出错!因为&#34;D::showa&#34;具有二义性
</span><span style=color:#75715e></span>    d.b <span style=color:#f92672>=</span> <span style=color:#ae81ff>22</span>;
    d.showa();  <span style=color:#75715e>// 输出 11，若不是虚继承，D::showa 具有二义性
</span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;d.b=&#34;</span><span style=color:#f92672>&lt;&lt;</span>d.b<span style=color:#f92672>&lt;&lt;</span>endl; <span style=color:#75715e>//输出Dobj.b=22
</span><span style=color:#75715e></span>}

</code></pre></div><p>消除二义性。</p><h2 id=输入输出流>输入/输出流<a hidden class=anchor aria-hidden=true href=#输入输出流>#</a></h2><h3 id=流类简介>流类简介<a hidden class=anchor aria-hidden=true href=#流类简介>#</a></h3><p>C++中凡是数据从一个地方传输到另一个地方的操作都是<strong>流</strong>的操作。</p><ul><li>读操作：被称为(从流中)“提取”</li><li>写操作：被称为(向流中)“插入”</li></ul><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/abeelan/image-hosting-service/img/image-20230326222416127.png alt=image-20230326222416127></p><p>为了避免多重继承的二义性，从 <code>ios</code> 派生 <code>istream</code> 和 <code>ostream</code> 时，均使用了 <code>virtual</code> 关键字（虚继承）。</p><ul><li>istream：提供了流的大部分输入操作，对系统预定义的所有输入流重载提取运算符 <code>>></code></li><li>ostream：对系统定义的所有输出流重载插入运算符 <code>&lt;&lt;</code></li></ul><h2 id=iostream-类库>iostream 类库<a hidden class=anchor aria-hidden=true href=#iostream-类库>#</a></h2><p>常见的头文件：</p><ul><li>iostream：包含操作所有<strong>输入/输出流</strong>所需要的基本信息</li><li>iomanip：setw()、setprecision()、setfill()、setbase() 等</li><li>fstream：包含处理<strong>文件</strong>的有关信息，童工建立文件、读/写文件的各种操作接口</li></ul><h3 id=iostream>iostream<a hidden class=anchor aria-hidden=true href=#iostream>#</a></h3><p>头文件 iostream 包含操作所有输入/输出流所需的基本信息，含有 4 个标准流对象：</p><ul><li><strong>cout</strong>：标准输出流，与标准输出设备（显示器）相关联，可以被重定向为向文件里写入数据；</li><li><strong>cin</strong>：标准输入流，与标准输入设备（键盘）相关联，可以被重定向为从文件中读取数据；</li><li><strong>cerr</strong>：输出错误信息，与标准错误信息输出设备（显示器）相关联（非缓冲），不能被重定向；</li><li><strong>clog</strong>：输出错误信息，与标准错误信息输出设备（显示器）相关联（缓冲），不能被重定向。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 将标准输出cout重定向到文件
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>int</span> x,y;
	cin<span style=color:#f92672>&gt;&gt;</span>x<span style=color:#f92672>&gt;&gt;</span>y;
	freopen(<span style=color:#e6db74>&#34;test.txt&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>, stdout); <span style=color:#75715e>// 将标准输出重定向到文件test.txt 
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(y<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) <span style=color:#75715e>// 除数为0, 则输出错误信息
</span><span style=color:#75715e></span>		cerr<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;error.&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl; 
    <span style=color:#66d9ef>else</span>
		cout<span style=color:#f92672>&lt;&lt;</span>x<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;/&#34;</span><span style=color:#f92672>&lt;&lt;</span>y<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;=&#34;</span><span style=color:#f92672>&lt;&lt;</span>x<span style=color:#f92672>/</span>y<span style=color:#f92672>&lt;&lt;</span>endl; 
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>函数 <strong>freopen()</strong> 的功能是将 stream 按 mode 指定的模式重定向到路径 path 指向的文件。</p><h4 id=iomanip>iomanip<a hidden class=anchor aria-hidden=true href=#iomanip>#</a></h4><p>C++ 进行 <code>I/O</code> 格式控制的方式一般有使用流操纵符、设置标志字和调用成员函数。</p><h5 id=流操纵符>流操纵符<a hidden class=anchor aria-hidden=true href=#流操纵符>#</a></h5><p>不带参数的流操纵符：</p><ul><li><strong>endl</strong>（O）：<strong>换行符</strong>，输入一个换行符，清空流</li><li>ends（O）：输出字符串结束，清空流</li><li>flush（O）：清空流缓冲区</li><li><strong>dec</strong>（I/O，默认）：十进制形式</li><li><strong>hex</strong>（I/O）：十六进制形式</li><li><strong>oct</strong>（I/O）：八进制形式</li><li>ws（O）：提取空白字符</li></ul><p>包含格式化 I/O 的带参数流操纵符，可用于指定数据输入/输出的格式。例如：</p><ul><li><strong>setw(int w)</strong>：指定输出宽度为 w 个字符，或输入字符串时读入 w 个字符，一次有效</li><li><strong>setprecision()</strong>：设置有效数字位数，全部数字个数</li><li><strong>setfill()</strong>：指定输出宽度，宽度不足时用空格填充</li><li><strong>setbase()</strong>：输入表示数值进制的前缀</li><li>setiosflags()：设置标志字</li></ul><p>进制标识：</p><ul><li>十六进制常量——前缀0x，0~9、a~f</li><li><strong>十进制常量——无前后缀</strong>，0~9</li><li>八进制常量——前缀0，0~7；080就是非法数</li><li>长整型常量——后缀L或l</li></ul><h5 id=标志字>标志字<a hidden class=anchor aria-hidden=true href=#标志字>#</a></h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;iostream&gt; </span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;iomanip&gt; </span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std; 

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>double</span> x<span style=color:#f92672>=</span><span style=color:#ae81ff>12.34</span>; 
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;1)&#34;</span><span style=color:#f92672>&lt;&lt;</span>setiosflags(ios<span style=color:#f92672>::</span>scientific<span style=color:#f92672>|</span>ios<span style=color:#f92672>::</span>showpos)<span style=color:#f92672>&lt;&lt;</span>x<span style=color:#f92672>&lt;&lt;</span>endl; 
    <span style=color:#75715e>// ios::scientific 科学计数法 showpos 正数前加 “+” 号
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 输出：+1.234000e+001
</span><span style=color:#75715e></span>    
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;2)&#34;</span><span style=color:#f92672>&lt;&lt;</span>setiosflags(ios<span style=color:#f92672>::</span>fixed)<span style=color:#f92672>&lt;&lt;</span>x<span style=color:#f92672>&lt;&lt;</span>endl; 
    <span style=color:#75715e>// fixed 定点形式表示浮点数
</span><span style=color:#75715e></span>    <span style=color:#75715e>// +12.34
</span><span style=color:#75715e></span>    
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;3)&#34;</span><span style=color:#f92672>&lt;&lt;</span>resetiosflags(ios<span style=color:#f92672>::</span>fixed)<span style=color:#f92672>&lt;&lt;</span>setiosflags(ios<span style=color:#f92672>::</span>scientific<span style=color:#f92672>|</span>ios<span style=color:#f92672>::</span>showpos)<span style=color:#f92672>&lt;&lt;</span>x<span style=color:#f92672>&lt;&lt;</span>endl; 
    <span style=color:#75715e>// +1.2340003+001
</span><span style=color:#75715e></span>    
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;4)&#34;</span><span style=color:#f92672>&lt;&lt;</span>resetiosflags(ios<span style=color:#f92672>::</span>showpos)<span style=color:#f92672>&lt;&lt;</span>x<span style=color:#f92672>&lt;&lt;</span>endl;
    <span style=color:#75715e>// 清除要输出正号的标志 
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 1.234000e+001
</span><span style=color:#75715e></span>    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h4 id=调用-cout-的成员函数>调用 cout 的成员函数<a hidden class=anchor aria-hidden=true href=#调用-cout-的成员函数>#</a></h4><table><thead><tr><th>成员函数</th><th>作用相同的流操纵符</th></tr></thead><tbody><tr><td>precision(int np)</td><td>setprecision(np)</td></tr><tr><td><strong>width(int nw)</strong></td><td>setw(nw)</td></tr><tr><td>fill(char cFill)</td><td>setfill(cFill)</td></tr><tr><td><strong>setf(long iFlags)</strong></td><td>setiosflags(iFlags)</td></tr><tr><td><strong>unsetf(long iFlags)</strong></td><td>resetiosflags(iFIags)</td></tr></tbody></table><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>cout.put(<span style=color:#e6db74>&#39;d&#39;</span>);  <span style=color:#75715e>// cout&lt;&lt;&#39;d&#39;，向输入流中插入一个字符
</span><span style=color:#75715e></span>cout.write();  <span style=color:#75715e>// 向输出流汇总插入 数据块
</span></code></pre></div><h4 id=调用-cin-的成员函数>调用 cin 的成员函数<a hidden class=anchor aria-hidden=true href=#调用-cin-的成员函数>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// get() 函数
</span><span style=color:#75715e></span><span style=color:#66d9ef>while</span>((ch<span style=color:#f92672>=</span>cin.get()) <span style=color:#f92672>!=</span> EOF) <span style=color:#75715e>//当文件没有结束时继续进行循环 
</span><span style=color:#75715e></span>{
	cout.put(ch);
} 

<span style=color:#75715e>// getline() 函数，从输入流中读取一行字符
</span><span style=color:#75715e>// 函数原型
</span><span style=color:#75715e></span>istream <span style=color:#f92672>&amp;</span> getline(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> buf, <span style=color:#66d9ef>int</span> bufSize);  <span style=color:#75715e>// 读取 size-1 个字符到缓冲区 或到 \n 截止
</span><span style=color:#75715e></span>istream <span style=color:#f92672>&amp;</span> getline(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> buf, <span style=color:#66d9ef>int</span> bufSize, <span style=color:#66d9ef>char</span> delim);  <span style=color:#75715e>// 或到 delim 截止
</span><span style=color:#75715e></span>
<span style=color:#75715e>// eof() 函数，用于判断输入流是否已经结束，返回 true 表示输入结束
</span><span style=color:#75715e>// 测试是否到文件尾，到文件返回 1，否则返回 0
</span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>eof</span>( );

<span style=color:#75715e>// ignore() 函数，跳过输入流中的 n 个字符 或 delim 及其之前的所有字符
</span><span style=color:#75715e>// cin.ignore() == cin.ignore(1, EOF) 默认值，即跳过一个字符
</span><span style=color:#75715e></span>istream <span style=color:#f92672>&amp;</span> ignore(<span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>int</span> delim<span style=color:#f92672>=</span>EOF);

<span style=color:#75715e>// peek() 函数，返回输入流中的当前字符，只看一眼
</span><span style=color:#75715e>// 输入流已经结束的情况下，cin.peek() 返回 EOF
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>peek</span>( );

</code></pre></div><h2 id=文件和操作>文件和操作<a hidden class=anchor aria-hidden=true href=#文件和操作>#</a></h2><h4 id=文件基本概念和文件流类>文件基本概念和文件流类<a hidden class=anchor aria-hidden=true href=#文件基本概念和文件流类>#</a></h4><p>根据文件数据的编码方式不同分为：</p><ul><li><p><strong>文本文件</strong></p></li><li><p><strong>二进制文件</strong></p></li></ul><p>根据存取方式不同分为：</p><ul><li><strong>顺序存取文件</strong>：按照文件中数据存储次序进行顺序操作，访问第 i 个数据，首先得访问 i-1</li><li><strong>随机存取文件</strong>：根据应用需要，通过命令移动位置指针直接定位到文件位置</li></ul><p>对文件的基本操作分为：</p><ul><li>读文件：将<strong>文件</strong>中的数据<strong>读入内存</strong>之中，也称为输入</li><li>写文件：将<strong>内存</strong>中的数据<strong>存入文件</strong>之中，也称为输出</li></ul><p>C++ 标准类库中有 3 个流类可以用于文件操作，统称为文件流类，分别如下：</p><ul><li>ifstream：用于从文件中读取数据</li><li>ofstream：用于向文件中写入数据</li><li>fstream：即可用于读取数据，也可用于写入数据</li></ul><p>使用这 3 个流类，需要包含 <code>fstream</code> 头文件。</p><p>在程序中，要使用一个文件，必须包含3个基本步骤：</p><ul><li>打开(open)文件</li><li>操作文件：对文件进行读/写</li><li>关闭(close)文件</li></ul><p>C++ 文件流类有相应的成员函数来实现打开、读、写、关闭等文件操作。</p><h4 id=打开和关闭文件>打开和关闭文件<a hidden class=anchor aria-hidden=true href=#打开和关闭文件>#</a></h4><p>打开文件的方式有以下两种:</p><ol><li>先建立流对象，然后调用 <code>open()</code> 函数连接外部文件。格式如下:
<code>流类名 对象名;</code>
<code>对象名.open(文件名, 模式);</code></li><li>调用流类带参数的构造函数，建立流对象同时连接外部文件，格式如下：
<code>流类名 对象名(文件名，模式);</code></li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 输入：方式一
</span><span style=color:#75715e></span>ifstream inFile; <span style=color:#75715e>//建立输入文件流对象
</span><span style=color:#75715e></span>inFile.open(<span style=color:#e6db74>&#34;data.txt&#34;</span>, ios<span style=color:#f92672>::</span>in); <span style=color:#75715e>//连接文件，指定打开模式，默认为 in
</span><span style=color:#75715e>// 输入：方式二
</span><span style=color:#75715e></span>ifstream <span style=color:#a6e22e>inFile</span>(<span style=color:#e6db74>&#34;data.txt&#34;</span>, ios<span style=color:#f92672>::</span>in);

<span style=color:#75715e>// 输出：方式一
</span><span style=color:#75715e></span>ofstream outFile; <span style=color:#75715e>//建立输入文件流对象
</span><span style=color:#75715e></span>outFile.open(<span style=color:#e6db74>&#34;c:</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>c2019</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>newfile&#34;</span>,ios<span style=color:#f92672>::</span>out <span style=color:#f92672>|</span> ios<span style=color:#f92672>::</span>binary);  <span style=color:#75715e>// 二进制文件
</span><span style=color:#75715e>// 输出：方式二
</span><span style=color:#75715e></span>ofstream <span style=color:#a6e22e>outFile</span>(<span style=color:#e6db74>&#34;c:</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>c2019</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>newfile&#34;</span>,ios<span style=color:#f92672>::</span>out <span style=color:#f92672>|</span> ios<span style=color:#f92672>::</span>binary);
</code></pre></div><p>使用 fstream 中的成员函数 <strong>close()</strong> 关闭文件。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>inFile.close();
outFile.close();
</code></pre></div><h4 id=文件读写操作>文件读写操作<a hidden class=anchor aria-hidden=true href=#文件读写操作>#</a></h4><h5 id=读写文本文件>读写文本文件<a hidden class=anchor aria-hidden=true href=#读写文本文件>#</a></h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>/*
</span><span style=color:#75715e>	键盘输入学生的学号、姓名和成绩，存入 score.txt 中
</span><span style=color:#75715e>	每行保存一名学生的成绩信息，各项数据之间用空格分隔
</span><span style=color:#75715e>*/</span>
<span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fstream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>char</span> id[<span style=color:#ae81ff>11</span>], name[<span style=color:#ae81ff>21</span>];
    <span style=color:#66d9ef>int</span> score;
    
    <span style=color:#75715e>// 写文件
</span><span style=color:#75715e></span>    ofstream outFile;
    outFile.open(<span style=color:#e6db74>&#34;score.txt&#34;</span>, ios<span style=color:#f92672>::</span>out);  <span style=color:#75715e>// 写方式打开文件
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>outFile) {
        cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;创建文件失败！&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    }
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;请输入：学号 姓名 成绩（以 Ctrl+Z 结束！）&#34;</span>;
    <span style=color:#66d9ef>while</span>(cin<span style=color:#f92672>&gt;&gt;</span>id<span style=color:#f92672>&gt;&gt;</span>name<span style=color:#f92672>&gt;&gt;</span>score)
		outFile<span style=color:#f92672>&lt;&lt;</span>id<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span><span style=color:#f92672>&lt;&lt;</span>name<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span><span style=color:#f92672>&lt;&lt;</span>score<span style=color:#f92672>&lt;&lt;</span>endl; <span style=color:#75715e>//向流中插入数据 
</span><span style=color:#75715e></span>    outFile.close();
    
    <span style=color:#75715e>// 读文件
</span><span style=color:#75715e></span>    iftream inFile(<span style=color:#e6db74>&#34;score.txt&#34;</span>, ios:in);  <span style=color:#75715e>// 读方式打开文件
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>inFile) {
        cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;打开文件失败！&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    }
    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;学生学号 姓名</span><span style=color:#ae81ff>\t\t\t</span><span style=color:#e6db74>成绩</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; 
    <span style=color:#66d9ef>while</span>(inFile<span style=color:#f92672>&gt;&gt;</span>id<span style=color:#f92672>&gt;&gt;</span>name<span style=color:#f92672>&gt;&gt;</span>score)  <span style=color:#75715e>// 读入文件
</span><span style=color:#75715e></span>		cout<span style=color:#f92672>&lt;&lt;</span>left<span style=color:#f92672>&lt;&lt;</span>setw(<span style=color:#ae81ff>10</span>)<span style=color:#f92672>&lt;&lt;</span>id<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
    	cout<span style=color:#f92672>&lt;&lt;</span>setw(<span style=color:#ae81ff>20</span>)<span style=color:#f92672>&lt;&lt;</span>name<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
        cout<span style=color:#f92672>&lt;&lt;</span>setw(<span style=color:#ae81ff>3</span>)<span style=color:#f92672>&lt;&lt;</span>right<span style=color:#f92672>&lt;&lt;</span>score<span style=color:#f92672>&lt;&lt;</span>endl;
    inFile.close( );
	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h5 id=读写二进制文件>读写二进制文件<a hidden class=anchor aria-hidden=true href=#读写二进制文件>#</a></h5><p>需要用 <code>binary</code> 方式打开二进制文件。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 用 ostream::write() 成员函数写文件
</span><span style=color:#75715e></span>ostream <span style=color:#f92672>&amp;</span> write(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> buffer, <span style=color:#66d9ef>int</span> nCount);
<span style=color:#75715e>// e.g.
</span><span style=color:#75715e></span>ofstream <span style=color:#a6e22e>outFile</span>(<span style=color:#e6db74>&#34;students.dat&#34;</span>,ios<span style=color:#f92672>::</span>out<span style=color:#f92672>|</span>ios<span style=color:#f92672>::</span>binary); 
outFile.write((<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>stu, <span style=color:#66d9ef>sizeof</span>(stu)); 

<span style=color:#75715e>// 用 istream::read() 成员函数读文件
</span><span style=color:#75715e></span>istream <span style=color:#f92672>&amp;</span>read(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> buffer, <span style=color:#66d9ef>int</span> nCount);

<span style=color:#75715e>// 用 ostream::gcount() 成员函数得到读取字节数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>gcount</span>();
</code></pre></div><h5 id=用成员函数-put-和-get-读写文件>用成员函数 put() 和 get() 读写文件<a hidden class=anchor aria-hidden=true href=#用成员函数-put-和-get-读写文件>#</a></h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// 不带参数，提取一个字符并返回，当遇到文件结束符，返回 EOF
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get</span>();

<span style=color:#75715e>// 从指定输入流中提取一个字符
</span><span style=color:#75715e></span>istream<span style=color:#f92672>&amp;</span> get(<span style=color:#66d9ef>char</span> <span style=color:#f92672>&amp;</span>rch);

<span style=color:#75715e>// 从流的当前字符开始，读取 nCount-1 个字符，到 delim 结束
</span><span style=color:#75715e></span>istream<span style=color:#f92672>&amp;</span> get(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pch, <span style=color:#66d9ef>int</span> nCount, <span style=color:#66d9ef>char</span> delim<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>’\</span>n<span style=color:#960050;background-color:#1e0010>’</span>);

<span style=color:#75715e>// put 向输出流中插入一个字节
</span><span style=color:#75715e></span>ostream<span style=color:#f92672>&amp;</span> put(<span style=color:#66d9ef>char</span> ch);
</code></pre></div><h5 id=文本文件与二进制文件异同>文本文件与二进制文件异同<a hidden class=anchor aria-hidden=true href=#文本文件与二进制文件异同>#</a></h5><p>在输入/输出过程中，系统要对内外存的数据格式进行相应转换。</p><ul><li><p>文本文件：以<strong>文本形式</strong>存储数据</p><ul><li>优点：具有较高的兼容性</li><li>缺点：1.存储一批纯数值信息时，要人为地添加分隔符；2.不便于对数据进行随机访问。</li></ul></li><li><p>二进制文件：以<strong>二进制形式</strong>存储数据</p><ul><li>优点：便于对数据实行随机访问 (相同数据类型的数据所占空间的大小均是相同的，不必在数据之间人为地添加分隔符)，在输入/输出过程中，系统不需要对数据进行任何转换。</li><li>缺点：数据兼容性差</li></ul></li></ul><p>通常纯文本信息(如字符串)以文本文件形式存储，而将数值信息以二进制文件形式存储。</p><h4 id=随机访问文件>随机访问文件<a hidden class=anchor aria-hidden=true href=#随机访问文件>#</a></h4><p>顺序文件：如果一个文件只能进行顺序存取操作，则称为顺序文件。</p><ul><li>典型的顺序文件 (设备)是键盘、显示器和保存在磁带上的文件</li><li>在访问文件的过程中，若严格按照数据保存的次序从头到尾访问文件，则称为顺序访问</li><li>只能进行顺序访问</li></ul><p>随机文件：如果一个文件可以在文件的任意位置进行存取操作，则称为随机文件。</p><ul><li><p>磁盘文件就是典型的随机文件</p></li><li><p>在访问文件的过程中，若不必按照数据的存储次序访问文件，而是要根据需要在文件的不同位置进行访问，则称为随机访问</p></li><li><p>既可以进行顺序访问，也可以进行随机访问</p></li></ul><p>**类 istream **中与位置指针相关的函数如下:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>/* 1. 移动读指针函数 */</span>
<span style=color:#75715e>// 该函数的功能是将读指针设置为 pos，即将读指针移动到文件的 pos 字节处
</span><span style=color:#75715e></span>istream <span style=color:#f92672>&amp;</span> seekg(<span style=color:#66d9ef>long</span> pos);

<span style=color:#75715e>// 将读指针按照 seek_dir 的指示(方向)移动offset个字节
</span><span style=color:#75715e>// 其中seek_dir 是在类ios中定义的一个枚举类型 
</span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>seek_dir</span> {beg<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, cur, end};
<span style=color:#75715e>// ios::beg 流的开始位置。此时，offset 应为非负整数
</span><span style=color:#75715e>// ios::cur 表示流的当前位置。offset 为正数则表示向后(文件尾)移动，为负数则表示向前(文件头)移动。
</span><span style=color:#75715e>// ios::end 表示流的结束位置。此时 offset 应为非正整数
</span><span style=color:#75715e></span>istream <span style=color:#f92672>&amp;</span> seekg(<span style=color:#66d9ef>long</span> offset, ios<span style=color:#f92672>::</span>seek_dir dir);

<span style=color:#75715e>/* 2. 返回写指针当前位置的函数 */</span>
<span style=color:#75715e>// 函数返回值为流中读指针的当前位置。
</span><span style=color:#75715e></span><span style=color:#66d9ef>long</span> <span style=color:#a6e22e>tellg</span>(); 
</code></pre></div><p>**类 ostream **中与位置指针相关的函数如下:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>/* 1. 移动写指针函数 */</span>
<span style=color:#75715e>// 该函数的功能是将写指针设置为 pos，即将写指针移动到文件的 pos 字节处
</span><span style=color:#75715e></span>ostream <span style=color:#f92672>&amp;</span> seekp(<span style=color:#66d9ef>long</span> pos);
<span style=color:#75715e>// 该函数的功能是将写指针按 seek_dir 指示的方向移动 offset 个字节
</span><span style=color:#75715e></span>ostream <span style=color:#f92672>&amp;</span> seekp(<span style=color:#66d9ef>long</span> offset, ios<span style=color:#f92672>::</span>seek_dir dir);

<span style=color:#75715e>/* 2. 返回写指针当前位置的函数 */</span>
<span style=color:#75715e>// 函数的返回值为流中写指针的当前位置
</span><span style=color:#75715e></span><span style=color:#66d9ef>long</span> <span style=color:#a6e22e>tellp</span>();
</code></pre></div><h2 id=函数模板与类模板>函数模板与类模板<a hidden class=anchor aria-hidden=true href=#函数模板与类模板>#</a></h2><h4 id=函数模板>函数模板<a hidden class=anchor aria-hidden=true href=#函数模板>#</a></h4><p>设计程序中的函数时，可能会遇到函数中参数的类型有差异，但需要实现的功能类似的情形。函数重载可以处理这种情形。重载函数的参数表中，可以写不同类型的参数，从而可以处理不同的情形。</p><p>为了提高效率，实现代码复用，C++ 提供了一种处理机制，即使用<strong>函数模板</strong>。函数在设计时并不使用实际的类型，而是使用虚拟的类型参数。</p><p>当用实际的类型来实例化这种函数时，将函数模板与某个具体数据类型连用。**编译器将以函数模板为样板，生成一个函数，即产生了模板函数，这个过程称为函数模板实例化。**函数模板实例化的过程由编译器完成。程序设计时并不给出相应数据的类型，编译时，由编译器根据实际的类型进行实例化。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std; 

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span> 
T abs(T x) {
	<span style=color:#66d9ef>return</span> x<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>?-</span>x:x; 
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>int</span> n<span style=color:#f92672>=-</span><span style=color:#ae81ff>5</span>;
	<span style=color:#66d9ef>int</span> m<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>;
	<span style=color:#66d9ef>double</span> d<span style=color:#f92672>=-</span><span style=color:#ae81ff>.5</span>;
	<span style=color:#66d9ef>float</span> f<span style=color:#f92672>=</span><span style=color:#ae81ff>3.2</span>; 
    cout<span style=color:#f92672>&lt;&lt;</span>n<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;的绝对值是:&#34;</span><span style=color:#f92672>&lt;&lt;</span>abs(n)<span style=color:#f92672>&lt;&lt;</span>endl; 
    cout<span style=color:#f92672>&lt;&lt;</span>m<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;的绝对值是:&#34;</span><span style=color:#f92672>&lt;&lt;</span>abs(m)<span style=color:#f92672>&lt;&lt;</span>endl; 
    cout<span style=color:#f92672>&lt;&lt;</span>d<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;的绝对值是:&#34;</span><span style=color:#f92672>&lt;&lt;</span>abs(d)<span style=color:#f92672>&lt;&lt;</span>endl; 
    cout<span style=color:#f92672>&lt;&lt;</span>f<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;的绝对值是:&#34;</span><span style=color:#f92672>&lt;&lt;</span>abs(f )<span style=color:#f92672>&lt;&lt;</span>endl; 
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>函数与函数模板也是允许重载的。在函数和函数模板名字相同的情况下，一条函数调用语句到底应该被匹配成对哪个函数或哪个模板的调用呢?</p><p>C++ 编译器遵循以下先后顺序：</p><ol><li>先找参数完全匹配的普通函数(不是由模板实例化得到的模板函数)；</li><li>再找参数完全匹配的模板函数；</li><li>然后找实参经过自动类型转换后能够匹配的普通函数；</li><li>如果上面的都找不到，则报错。</li></ol><h4 id=类模板>类模板<a hidden class=anchor aria-hidden=true href=#类模板>#</a></h4><p>通过类模板，可以实例化一个个的类。</p><ul><li>继承机制也是在一系列的类之间建立某种联系，类是相同类型事物的抽象，有继承关系的类可以具有不同的操作。</li><li>模板是不同类型的事物具有相同的操作，实例化后的类之间没有联系，相互独立。</li></ul><p>不能使用类模板来直接生成对象，因为类型参数是不确定的，必须先为模板参数指定“实参”，即模板要“实例化”后，才可以创建对象。也就是说，当使用类模板创建对象时，要随类模板名给出对应于类型形参或普通形参的具体实参。</p><p>格式如下:</p><ul><li><p><code>类模板名 &lt;模板参数表> 对象名1,...,对象名n;</code></p></li><li><p><code>类模板名 &lt;模板参数表> 对象名1(构造函数实参),...,对象名构造函数实参);</code></p></li></ul><p>类模板中的成员函数<strong>全部都是模板函数</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std; 

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> 
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestClass</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
	T buffer[<span style=color:#ae81ff>10</span>];
	T <span style=color:#a6e22e>getData</span>(<span style=color:#66d9ef>int</span> j); 
};

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
T TestClass<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>getData(<span style=color:#66d9ef>int</span> j) {
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>(buffer<span style=color:#f92672>+</span>j);
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#75715e>// char 取代 T，从而实例化为一个具体的类
</span><span style=color:#75715e></span>    TestClass<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> ClassInstA;  
    <span style=color:#66d9ef>int</span> i; 
    <span style=color:#66d9ef>char</span> cArr[<span style=color:#ae81ff>6</span>]<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;abcde&#34;</span>; 
    <span style=color:#66d9ef>for</span>(i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>) {
        ClassInstA.buffer[i]<span style=color:#f92672>=</span>cArr[i];
    }
    <span style=color:#66d9ef>for</span>(i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>char</span> res <span style=color:#f92672>=</span> ClassInstA.getData(i);
        cout<span style=color:#f92672>&lt;&lt;</span>res<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
    }
    cout<span style=color:#f92672>&lt;&lt;</span>endl;
    
    <span style=color:#75715e>// 实例化为另外一个具体的类 double
</span><span style=color:#75715e></span>    TestClass<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> ClassInstF; 
    fArr[<span style=color:#ae81ff>6</span>]<span style=color:#f92672>=</span>{<span style=color:#ae81ff>12.1</span>,<span style=color:#ae81ff>23.2</span>,<span style=color:#ae81ff>34.3</span>,<span style=color:#ae81ff>45.4</span>,<span style=color:#ae81ff>56.5</span>,<span style=color:#ae81ff>67.6</span>}; 
    <span style=color:#66d9ef>for</span>(i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>6</span>; i<span style=color:#f92672>++</span>) {
        ClassInstF.buffer[i]<span style=color:#f92672>=</span>fArr[i]<span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>;
    }
    <span style=color:#66d9ef>for</span>(i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>6</span>; i<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>double</span> res <span style=color:#f92672>=</span> ClassInstF.getData(i);
        cout<span style=color:#f92672>&lt;&lt;</span>res<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
    }
    cout<span style=color:#f92672>&lt;&lt;</span>endl;
    
	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>; 
}
</code></pre></div><p>类之间允许继承，类模板之间也允许继承。具体来说，类模板和类模板之间、类模板和类之间可以互相继承，它们之间的常见派生关系有以下4种情况:</p><ol><li>普通类继承模板类</li><li>类模板继承普通类</li><li>类模板继承类模板</li><li>类模板继承模板类。</li></ol><p>根据类模板实例化的类即是模板类。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt; </span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std; 

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TBase</span> {  <span style=color:#75715e>// 类模板，基类
</span><span style=color:#75715e></span>	T data;
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
	<span style=color:#66d9ef>void</span> print() { cout<span style=color:#f92672>&lt;&lt;</span>data<span style=color:#f92672>&lt;&lt;</span>endl; } 
};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span><span style=color:#f92672>:</span><span style=color:#66d9ef>public</span> TBase<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> {};  <span style=color:#75715e>//从模板继承，普通类
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
	Derived d; <span style=color:#75715e>// 普通派生类的对象 
</span><span style=color:#75715e></span>    d.print(); <span style=color:#75715e>// 调用类模板中的成员函数
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://abeelan.github.io/img/wechatpay.jpg alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://abeelan.github.io/img/alipay.jpg alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick="var qr=document.getElementById('QR');qr.style.opacity==='0'?qr.style.opacity='1':qr.style.opacity='0'">
<span>🧧 鼓励一下 🧧</span></button></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://abeelan.github.io/posts/tech/%E5%85%B6%E4%BB%96/hugo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2v2/><span class=title>« 上一页</span><br><span>Hugo - 博客搭建记录（最新且完整）</span></a>
<a class=next href=https://abeelan.github.io/posts/read/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/><span class=title>下一页 »</span><br><span>《计算机网络原理》个人笔记</span></a></nav></footer></div><style>.comments_details summary::marker{font-size:20px;content:'👉展开评论';color:var(--content)}.comments_details[open] summary::marker{font-size:20px;content:'👇关闭评论';color:var(--content)}</style><div><details class=comments_details><summary style="cursor:pointer;margin:50px 0 20px;width:130px"><span style=font-size:20px;color:var(--content)>...</span></summary><div id=tcomment></div></details><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script><script>twikoo.init({envId:null,el:"#tcomment",lang:'zh-CN',region:"ap-beijing",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://abeelan.github.io/ style=color:#939393>ABEE</a>
All Rights Reserved</span>
<a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;
<span><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style=display:inline-block;text-decoration:none;height:20px;color:#939393><img src style="float:left;margin:0 5px 0 0"></a></span>
<span id=busuanzi_container><span class="fa fa-user"></span><span id=busuanzi_value_site_uv></span><span class="fa fa-eye"></span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span></span></a><script>document.addEventListener('scroll',function(e){const a=document.getElementById("read_progress"),b=document.documentElement.scrollHeight,c=document.documentElement.clientHeight,d=document.documentElement.scrollTop||document.body.scrollTop;a.innerText=((d/(b-c)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.body.addEventListener('copy',function(a){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let b=a.clipboardData||window.clipboardData;if(b){a.preventDefault();let c=window.getSelection().toString()+'\r\n\n————————————————\r\n'+'版权声明：本文为「'+"ABEE"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。'+'\r\n原文链接：'+location.href,d=window.getSelection().toString()+'\r\n\n————————————————\r\n'+'版权声明：本文为「'+"ABEE"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。'+'\r\n原文链接：'+location.href;b.setData('text/html',c),b.setData('text/plain',d)}}})</script><script>document.querySelectorAll('pre > code').forEach(c=>{const d=c.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='📄 复制';function i(){a.innerText='👌🏻 已复制!',setTimeout(()=>{a.innerText='📄 复制'},2e3)}a.addEventListener('click',d=>{if('clipboard'in navigator){let a=c.textContent+'\r\n————————————————\r\n'+'版权声明：本文为「'+"ABEE"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。'+'\r\n原文链接：'+location.href;navigator.clipboard.writeText(a),i();return}const a=document.createRange();a.selectNodeContents(c);const b=window.getSelection();b.removeAllRanges(),b.addRange(a);try{document.execCommand('copy'),i()}catch(a){}b.removeRange(a)});let j=c.className.replaceAll("language-",""),b=document.createElement("div"),f=document.createElement("div"),g=document.createElement("div"),h=document.createElement("div"),e=document.createElement("div");e.innerText=j,b.setAttribute('class','mac-tool'),f.setAttribute('class','mac bb1'),g.setAttribute('class','mac bb2'),h.setAttribute('class','mac bb3'),e.setAttribute('class','language-type'),b.appendChild(f),b.appendChild(g),b.appendChild(h),b.appendChild(e),d.classList.contains("highlight")?(d.appendChild(a),d.appendChild(b)):d.parentNode.firstChild==d||(c.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(c.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a),d.appendChild(b)):(c.parentNode.appendChild(a),d.appendChild(b)))})</script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&($(this).css("width","135%"),$(this).css("border-top-right-radius","var(--radius)"))}).on("mouseout",function(){$(this).css("width","100%"),$(this).css("border-top-right-radius","unset")})</script></body></html>